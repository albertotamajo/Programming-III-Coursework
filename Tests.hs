import Lib
import Test.QuickCheck
import Data.Array
import System.Random
import Control.Monad
import System.IO
import Control.Exception
import Data.List
import Data.Char


------------------------------------------------------------------------------------------------------------------------------------------------
--                                              AUXILIARY FUNCTIONS                                                                           --                      
-- asserts
--      This function takes two arguments and
--      checks whether they are equal.
--                                        
asserts :: Eq a => a -> a -> Bool
asserts x y = x==y

------------------------------------------------------------------------------------------------------------------------------------------------
--                                              PROPERTY FUNCTIONS                                                                            --

-- Words
--      This is a type whose values should be
--      words. Values of this type are used to randomly fill
--      a Word Search puzzle with words. 
--
newtype Words = Word {getString :: String} deriving (Show, Eq)


-- Words is an instance of Arbitrary so that it is possible
-- to randomly generate words.
--
instance Arbitrary Words where
    arbitrary = genWord  -- a generator of words


-- arrayWordDataBase
--      This is an array containing the most common 300 english words
--
arrayWordDataBase = listArray (0, (length filteredDataBase)-1) (filteredDataBase)
                  where
                    filteredDataBase = filter (\x -> length x > 1) wordDataBase  -- from the 'wordDataBase' list, words of length equal to 1 (single characters) are filtered out


-- genWord
--      This function is a generator for words.
--      A word is randomly generated by randomly
--      selecting a word in the 'arrayWordDataBase'.
--
genWord :: Gen Words        
       
genWord  = do
                n <- choose (0,(length arrayWordDataBase)-1)
                return (Word (arrayWordDataBase ! n ))
                    

-- Density 
--      This is a type containing double values which
--      can be used as upperbounds of the density
--      of a randomly created Word Search puzzle.
--               
newtype Density = Density {getDouble :: Double} deriving Show


-- Density is an instance of Arbitrary so that it is possible
-- to randomly generate words.
--
instance Arbitrary Density where
    arbitrary = do                       -- a generator for densities within the range (0.1,1) where 0.1 and 1 are included
                    n <- choose(0.1,1)
                    return (Density n)
                    

-- WordSeach
--      This is a type containing a 3-tuple whose values are 
--      a randomly generated Word Search puzze, the words used
--      to fill it and the upper bound density used to create it.
--
newtype WordSearch = WordSearch (IO WordSearchGrid, [Words], Density)

instance Show WordSearch where
    show (WordSearch (ioGrid, words, density)) = show words ++ "\n" ++ show density


-- WordSearch is an instance of Arbitrary so that it is possible
-- to randomly generate one of its values.
-- 
instance Arbitrary WordSearch where
    arbitrary = sized $ wordSearchGen


-- wordSearchGen
--      This function is a generator for values of WordSearch.
--      The number of words which are filled in the word search puzzle
--      is equal to the provided integer number + 1. However, up to 40 words
--      can be inserted in the Word Search puzzle so if the provided number is greater 
--      than 39, a random number between 0 and 39 is used to fill the grid.
--
wordSearchGen :: Int -> Gen WordSearch

wordSearchGen n | n <= 39 = do
                                Density d <- arbitrary
                                words <- vectorOf (n+1) (genWord)  -- n+1 words are generated 
                                let xs = map getString words
                                let filteredWords = (removeReverse .  removeInfixesBD) xs 
                                let leftOut = xs \\ filteredWords
                                let infixesCount = map (\f -> f filteredWords)(map isInfixOfCountBDList leftOut)
                                if not (or $ map (\x -> x > 1) infixesCount) then -- it is possible to create a word search puzzle with the provided words without duplicates
                                  do
                                    grid  <-  return $ createWordSearch xs d
                                    return (WordSearch (grid,words,(Density d)))
                                else  -- not possible to create a word search puzzle with the provided words without duplicates
                                    wordSearchGen n  -- retry generate another word search puzzle
                | otherwise = do
                                  n'<- choose (0,39)
                                  wordSearchGen n'
                                        
                                            
-- prop_satisfyingOrientations
--      This function checks that if for a given position, list and grid
--      a certain condition is satisfied by a list of orientations then 
--      the condition must hold for each of them.
--
prop_satisfyingOrientations :: (a -> a -> Bool) -> Posn -> Grid a -> [a] -> Bool

prop_satisfyingOrientations f p ax xs = and $ map (isSatisfying f xs p ax)  (satisfyingOrientations f p ax xs) 


-- prop_removeInfixesIdempotence
--      This function checks whether the Idempotence property
--      of the 'removeInfixes' function holds.
--
prop_removeInfixesIdempotence :: Eq a => [[a]] -> Bool

prop_removeInfixesIdempotence xs = (removeInfixes xs) == (removeInfixes . removeInfixes) xs


-- prop_removeInfixesNeverEmptyList
--      This function checks whether given a non empty list input
--      the 'removeInfixes' function never returns the empty list.
--
prop_removeInfixesNeverEmptyList :: Eq a => (NonEmptyList [a]) -> Bool

prop_removeInfixesNeverEmptyList (NonEmpty xs) = removeInfixes xs /= []


-- prop_removeReverseIdempotence
--      This function checks whether the Idempotence property
--      of the 'removeReverse' function holds.
--
prop_removeReverseIdempotence :: Eq a => [[a]] -> Bool

prop_removeReverseIdempotence xs =  (removeReverse xs) == (removeReverse . removeReverse) xs


-- prop_removeReverseNeverEmptyList
--      This function checks whether given a non empty list input
--      the 'removeReverse' never returns the empty list.
--
prop_removeReverseNeverEmptyList :: Eq a => (NonEmptyList [a]) -> Bool

prop_removeReverseNeverEmptyList (NonEmpty xs) = removeReverse xs /= []


-- prop_isReverseCommutativity
--      This function checks whether the commutative
--      property of the 'isReverse' function holds.
--
prop_isReverseCommutativity :: Eq a => [a] -> [a] -> Bool

prop_isReverseCommutativity xs ys = (isReverse xs ys) == (isReverse ys xs)


-- prop_isInfixOfAny_removeInfixes
--      This function checks whether it holds that if a list xs is an infix
--      of another list in a list of lists ys then adding xs in ys and remove
--      the infixes should result in a list without xs.
--      Alternatively, if xs is not an infix of another list in a list of lists
--      ys then adding xs in ys and remove the infixes should result in a list
--      with xs.
--
prop_isInfixOfAny_removeInfixes :: Eq a => [a] -> [[a]] -> Bool

prop_isInfixOfAny_removeInfixes xs ys | isInfixOfAny xs ys = (not.elem xs)  (removeInfixes ([xs]++ys))
                                      | otherwise = elem xs (removeInfixes ([xs]++ys))
                        
                        
-- prop_createWordSearchExactlyOnce
--      This function checks whether, given a randomly generated Word Search puzzle,
--      the words that are used to fill it are present exactly once in the puzzle          
--                                                
prop_createWordSearchExactlyOnce :: WordSearch -> Property

prop_createWordSearchExactlyOnce (WordSearch (ioGrid,words,Density density)) = ioProperty prop
                                                                             where
                                                                                xs = map getString words
                                                                                setChrs = nub (concat xs) 
                                                                                emptyValue = head ((map chr [1..]) \\ setChrs)
                                                                                prop = do
                                                                                         grid <- ioGrid
                                                                                         let array = listArray ((0,0),(length grid -1,length grid -1)) (concat grid)  -- a grid which resembles the Word Search puzzle
                                                                                         return (exactlyOnceInGrid emptyValue xs array) 

                                               
-- prop_createWordSearchDensity
--      This function checks whether, given a randomly generated Word Search puzzle,
--      the uppermost density that is used to generate it is greater than its actual
--      density.
--                                            
prop_createWordSearchDensity :: WordSearch -> Property

prop_createWordSearchDensity (WordSearch (ioGrid,words,Density density)) = ioProperty prop
                                                                         where
                                                                            xs = map getString words
                                                                            hiddenChars = sum $ map length xs
                                                                            dens x = ((fromIntegral hiddenChars) / ((fromIntegral (length x))^2 ))
    
                                                                            prop = do
                                                                                      grid <- ioGrid
                                                                                      let den = dens grid
                                                                                      return (den < density)
                                                                                        

-- prop_createWordSearchSolvable
--      This function checks whether, given a randomly generated Word Search puzzle,
--      it is effectively solvable. That is, all words thar are used to fill it must
--      be present.
--
prop_createWordSearchSolvable :: WordSearch -> Property

prop_createWordSearchSolvable (WordSearch (ioGrid,words,Density density)) = ioProperty prop
                                                                          where
                                                                            xs = map getString words
                                                                            prop = do
                                                                                        grid <- ioGrid
                                                                                        let solution = solveWordSearch xs grid
                                                                                        if (or $ map (\(a,b) -> b == Nothing ) solution) then return False else return True
                                         
                                                                                   
-- prop_createWordSearchSquare
--      This function checks whether, given a randomly generated Word Search puzzle,
--      it resembles a square grid. That is, it has the same number of rows and columns.
--                                      
prop_createWordSearchSquare :: WordSearch -> Property

prop_createWordSearchSquare (WordSearch (ioGrid,words,Density density)) = ioProperty prop
                                                                        where
                                                                            prop = do
                                                                                  grid <- ioGrid
                                                                                  return $ (replicate (length grid) (length grid)) == map length grid
 

-- prop_createWordSearchNoEmpties
--      This function checks whether, given a randomly generated Word Search puzzle,
--      it contains no empty cells.
-- 
prop_createWordSearchNoEmpties :: WordSearch -> Property

prop_createWordSearchNoEmpties (WordSearch (ioGrid,words,Density density)) = ioProperty prop
                                                                           where
                                                                            xs = map getString words
                                                                            setChrs = nub (concat xs) 
                                                                            emptyValue = head ((map chr [1..]) \\ setChrs)
                                                                            prop = do
                                                                                    grid <- ioGrid
                                                                                    let array = listArray ((0,0),(length grid -1,length grid -1)) (concat grid)  -- a grid which resembles the Word Search puzzle
                                                                                    return $ (lookupIndices emptyValue array) == []
                                                                                    
-- prop_createWordSearchSetCharacters
--      This function checks whether, given a randomly generated Word Search puzzle,
--      the character of each cell belongs to the set of characters appearing in the given input list.
--
prop_createWordSearchSetCharacters :: WordSearch -> Property
prop_createWordSearchSetCharacters (WordSearch (ioGrid,words,Density density)) = ioProperty prop
                                                                           where
                                                                            xs = map getString words
                                                                            setChrs = nub (concat xs)                                                                             
                                                                            prop = do
                                                                                    grid <- ioGrid
                                                                                    return $ and $ map (\ys -> ((nub ys) \\ setChrs) == [] ) grid
                                                           
                                                           
-- prop_createWordSearch_solveWordSearch
--      This function checks whether, given a randomly generated Word Search puzzle,
--      the function 'solveWordSearch' correctly solves it. That is, it finds all
--      words in it and their placement.
--                                                          
prop_createWordSearch_solveWordSearch :: WordSearch -> Property
prop_createWordSearch_solveWordSearch (WordSearch (ioGrid,words,Density density)) = ioProperty prop
                                                                           where
                                                                            xs = map getString words                                                                            
                                                                            prop = do
                                                                                    grid <- ioGrid
                                                                                    let solutions = solveWordSearch xs grid
                                                                                    let array = listArray ((0,0),(length grid -1,length grid -1)) (concat grid)  -- a grid which resembles the Word Search puzzle
                                                                                    let places = map (\(ws, Just ((a,b),o)) -> listElementsPositions (ws,(b,a),o)) solutions
                                                                                    let wordsInGrid = map (positionsToValues array) places 
                                                                                    return $ and $ map (\(a,b) -> a == b) (zip (sort wordsInGrid) (sort xs))
                                                                                    
                                                                                                           
-- prop_solveWordSearchEmptyPuzzle
--      This function checks whether given any
--      list of strings to insert in an empty
--      WordSeach puzzle results in the fact that none of
--      them is present in the puzzle.
--                                        
prop_solveWordSearchEmptyPuzzle :: [Words] ->  Property

prop_solveWordSearchEmptyPuzzle words = ioProperty prop
                                      where
                                        xs = map getString words
                                        result = solveWordSearch xs []
                                        (strings, places) = unzip result
                                        prop = if (length result == length xs && (replicate (length xs) Nothing) == places) then return True else return False


                                        
                                       
------------------------------------------------------------------------------------------------------------------------------------------------
--                                              +++ TASK 2 +++                                                                                --

-- eqMacroNameReplacement
--      This function takes as argument two lambda macro expressions e1 and e2.
--      It checks whether e1 and e2 are equivalent with all largest sub-expressions
--      in e1 which are defined in a macro replaced by their correspective macro
--      name in e2. 
--
eqMacroNameReplacement :: LamMacroExpr -> LamMacroExpr -> Bool

eqMacroNameReplacement (LamDef xs e1) (LamDef ys e2) | xs /= ys = False  -- if the macro definitions are different then the two lambda expressions cannot be equivalent
                                                     | otherwise = auxiliary (map (\(a,b) -> (b,a)) xs) e1 e2
                                                     where
                                                        -- this auxiliary function just does what described in the description of function 'eqMacroNameReplacement'
                                                        --
                                                        auxiliary :: [(LamExpr, String)] -> LamExpr -> LamExpr -> Bool
                                                        
                                                        auxiliary xs e1@(LamVar n1) e2@(LamVar n2) | e1 /= e2 = False  -- are not equivalent
                                                                                                   | otherwise = case lookup e1 xs of
                                                                                                                    Just _ -> False  -- e2 should have been replaced by a macro name
                                                                                                                    Nothing -> True  -- are equivalent
                                                                                                                    
                                                        auxiliary xs e1@(LamVar n1) (LamMacro x) = case lookup e1 xs of
                                                                                                        Just y ->  x==y  -- the macro name x should be equal to the first macro name defining e1
                                                                                                        Nothing -> False  -- are not equivalent as there is no macro name defining e1
                                                                                                        
                                                        auxiliary xs (LamMacro x) (LamMacro y) = case (lookup (LamMacro x) xs) of 
                                                                                                    Nothing -> x==y  -- the macro names x and y should be equal if there is no other macro name defining the expression 'LamMacro x'
                                                                                                    Just z -> case xPosition of  -- there exists a macro name defining 'LamMacro x'
                                                                                                                Nothing -> y==z  -- if the macro name x does not exists in the lookup list then y should be equal to the macro name defining 'LamMacro x'
                                                                                                                Just _ -> if xPosition <= zPosition then x==y else y==z  -- if the macro name x exists in the lookup list then y should be equal to x only if x precedes z otherwise y should be equal to z 
                                                                                                     where
                                                                                                        macros = map snd xs
                                                                                                        xPosition = lookup x (zip macros [1..])
                                                                                                        zPosition = lookup z (zip macros [1..])
                                                                                                        
                                                        auxiliary xs (LamAbs n1 e1) (LamAbs n2 e2) | n1 /= n2 = False  -- are not equivalent
                                                                                                   | otherwise = case lookup (LamAbs n1 e1) xs of
                                                                                                                    Just _ -> False  -- the second expression should have been replaced by a macro name
                                                                                                                    Nothing -> auxiliary xs e1 e2
                                                                                                                    
                                                        auxiliary xs (LamAbs n1 e1) (LamMacro x) = case lookup (LamAbs n1 e1) xs of
                                                                                                        Just y -> x==y  -- the macro name x should be equivalent to the macro name y
                                                                                                        Nothing -> False  -- are not equivalent as there is no macro name defining the first expression
                                                                                                        
                                                        auxiliary xs (LamApp e1 e2) (LamApp e3 e4) = case lookup (LamApp e1 e2) xs of
                                                                                                        Just _ -> False  -- the second expression should have been replaced by a macro name
                                                                                                        Nothing -> (auxiliary xs e1 e3) && (auxiliary xs e2 e4)
                                                                                                       
                                                        auxiliary xs (LamApp e1 e2) (LamMacro x) = case lookup (LamApp e1 e2) xs of
                                                                                                        Just y -> x==y  -- the macro name x should be equivalent to the macro name y
                                                                                                        Nothing -> False  -- are not equivalent as there is no macro name defining the first expression
                                                                                           
                                                        auxiliary _ _ _ = False  -- for all the other cases the two expressions are not equivalent
                                                       
                                                       
-- genMacroStrings
--      This function is a generator for macro names.
--      While the minimum size of the macro name is 1 character,
--      the maximum size is 10 characters.
--                                                        
genMacroStrings :: Gen String

genMacroStrings = do
                    n <- choose(1,10)
                    vectorOf n (choose ('A','Z'))


-- genPairMacroExpr
--      This function is a generator for a tuple whose
--      first element is a macro name and the second
--      element is the lambda expression defined by
--      the macro name. This function takes an integer 
--      number which is used as size to generate 
--      the lamda expression.
--
genPairMacroExpr :: Int -> Gen (String, LamExpr)

genPairMacroExpr n = do
                        x <- genMacroStrings
                        y <- genLamExpr' n
                        return (x,y)

                        
-- genPairMacroExprClosed
--      This function is a generator for a tuple whose
--      first element is a macro name and the second
--      element is the lambda expression defined by
--      the macro name. This function takes an integer 
--      number which is used as size to generate 
--      the lamda expression. This function differs
--      from the previous one because the generated
--      lambda expression is a closed term.
--
genPairMacroExprClosed :: Int -> Gen (String, LamExpr)

genPairMacroExprClosed n = do
                        x <- genMacroStrings
                        y <- genLamExprClosed' n
                        return (x,y)
                       
                       
-- genListPairMacroExpr
--      This function is a generator for a list of
--      tuples whose first element is a macro name and
--      the second element is the lambda expression defined by
--      the macro name. This function takes as input an
--      integer number which is used as size to generate
--      the lambda expressions. The list generated may have
--      a length ranging from 0 to 10.
--                    
genListPairMacroExpr :: Int -> Gen [(String,LamExpr)]

genListPairMacroExpr n = do
                            n2 <- choose (0,10)
                            vectorOf n2 (genPairMacroExpr n)

                            
-- genListPairMacroExprClosed
--      This function is a generator for a list of
--      tuples whose first element is a macro name and
--      the second element is the lambda expression defined by
--      the macro name.  This function takes as input an
--      integer number which is used as size to generate
--      the lambda expressions. The list generated may have
--      a length ranging from 0 to 10. This function differs from
--      the previous one because the generated lambda expressions
--      are all closed terms.
--  
genListPairMacroExprClosed :: Int -> Gen [(String,LamExpr)]

genListPairMacroExprClosed n = do
                            n2 <- choose (0,10)
                            vectorOf n2 (genPairMacroExprClosed n)                              
                            

-- genLamMacroExpr'
--      This function is a generator for a lambda expression.
--      It takes as argument an integer number which is used to
--      indicate the desired size of the generated lambda
--      expression.
--
genLamExpr' :: Int -> Gen LamExpr           

genLamExpr' 0 = oneof [liftM LamMacro (genMacroStrings), liftM LamVar (choose(0,100))]  -- if the size of the lambda expression must be 0 then only a lamda macro or or lambda variable can be chosen

genLamExpr' n = frequency [(1, liftM LamMacro (genMacroStrings)), (1, liftM LamVar (choose(0,100))), (3, liftM2 LamApp (genLamExpr' (n `div` 2)) (genLamExpr' (n `div` 2))),(3,liftM2 LamAbs (choose(0,100)) (genLamExpr' (n `div` 2))) ]  -- there is a 3/4 probability that either a lamda application or a lambda abstraction is chosen


-- genLamExprClosedMacros'
--      This function is a generator for a closed lambda expression.
--      In other words, the generated lambda expression does not contain
--      free variables. It takes as argument an integer number which is used to
--      indicate the desired size of the generated lambda
--      expression.
--
genLamExprClosed' :: Int -> Gen LamExpr 

genLamExprClosed' 0 = liftM LamMacro (genMacroStrings)  -- if the size is 0 then only a macro can be used so that to obtain a closed term
genLamExprClosed' n = genLamExprClosedAux [] n
                    where                         
                        genLamExprClosedAux :: [Int] -> Int -> Gen LamExpr
                        
                        genLamExprClosedAux xs 0 | xs == [] = liftM LamMacro (genMacroStrings)
                                                 | otherwise = oneof [(liftM LamVar (oneof (map return xs))), (liftM LamMacro (genMacroStrings))]
                                                                 
                        genLamExprClosedAux xs n | xs == [] = do
                                                                    randVar <- choose(0,100)
                                                                    oneof [ (liftM2 LamApp (genLamExprClosedAux [] (n `div` 2)) (genLamExprClosedAux [] (n `div` 2))) , (liftM2 LamAbs (return randVar) (genLamExprClosedAux [randVar] (n `div` 2))) ]  -- if no bound variables are present then it is not possible to use a lambda variable.
                                                    
                                                 | otherwise = do
                                                                    randVar <- oneof (map return xs)
                                                                    randVarAbs <- choose(0,100)
                                                                    frequency [(1, liftM LamMacro (genMacroStrings)), (1, liftM LamVar (return randVar)), (2, liftM2 LamApp (genLamExprClosedAux xs (n `div` 2)) (genLamExprClosedAux xs (n `div` 2))), (2,liftM2 LamAbs (return randVarAbs) (genLamExprClosedAux (randVarAbs:xs) (n `div` 2))) ]  -- there is a 2/3 probability that either a lamda application or a lambda abstraction is chosen
                                                                                                                    
                               
-- genLamMacroExpr
--      This function is a generator for a lambda macro expression.
--                
genLamMacroExpr :: Gen LamMacroExpr

genLamMacroExpr = sized $ (\n -> liftM2 LamDef (genListPairMacroExpr n) (genLamExpr' n))


-- genLamMacroExprClosedMacros
--      This function is a generator for a lambda macro expression whose
--      macros (if present) define closed terms lambda expressions.
--      It takes as argument an integer number which is used to
--      indicate the desired size of the generated lambda macro
--      expression.
--
genLamMacroExprClosedMacros :: Int ->  Gen LamMacroExpr

genLamMacroExprClosedMacros n = liftM2 LamDef (genListPairMacroExprClosed n) (genLamExpr' n)


-- LamMacroExpr is an instance of Arbitrary so that
-- it is possible to generate a random lambda macro expression.
--
instance Arbitrary LamMacroExpr where
    arbitrary = genLamMacroExpr  -- generator of lambda macro expressions


-- This type must be used only for those lambda macro expressions
-- containing macros defining closed terms lambda expressions.
--  
newtype LamMacroExprClosedMacros = Closed {getLamMacroExpr :: LamMacroExpr} deriving Show


instance Arbitrary LamMacroExprClosedMacros where
    arbitrary = sized $ gen
              where
                    gen n = do
                             e <- genLamMacroExprClosedMacros n
                             return (Closed e)
    
    
-- prop_unparseAndParse
--      This function checks whether, given a lambda expression e1,
--      unparsing and subsequently parsing it produces a lambda expression
--      e2 such that e1 and e2 are euivalent with all largest sub-expressions
--      in e1 which are defined in a macro replaced by their corresponding macro
--      name in e2. 
--
prop_unparseAndParse :: LamMacroExprClosedMacros -> Property

prop_unparseAndParse (Closed (LamDef xs e)) = ((length . nub ) macros == length macros) ==>   eqMacroNameReplacement (LamDef unexpanded e) parsed  
                         where
                            unexpanded = unexpandMacros xs
                            unparsed = prettyPrint (LamDef xs e)
                            Just parsed = parseLamMacro unparsed
                            (macros,exprs) = unzip xs
                            

-- prop_parseLamMacroUndefined
--      This function checks whether, given a lambda expression e which contains
--      macro name duplicates or free terms in macro name definitions, unparsing
--      and subsequently parsing it produces Nothing. This must hold because
--      unparsing e must produces a string which correctly encodes e which in turn is
--      not a well formed expression
--                           
prop_parseLamMacroUndefined :: LamMacroExpr -> Property

prop_parseLamMacroUndefined (LamDef xs e) = (((length . nub ) macros /= length macros) || (not $ and (map isClosed exprs))) ==> (parseLamMacro unparsed) == Nothing
                                          where
                                            unparsed = prettyPrint (LamDef xs e)
                                            (macros,exprs) = unzip xs
                                        
                                        
-- genLamMacroExprWithReplacements
--      This function is a generator for lambda macro expressions
--      which are very likely to contain sub-expressions that are
--      defined by one of its macros. Specifically, it is the lambda expression
--      defined by the left-most macro name to be very likely to be inside the 
--      lambda expression part of the generated lambda macro expression. Additionally,
--      all macro terms are closed.
--                                       
genLamMacroExprWithReplacements :: Gen LamMacroExpr

genLamMacroExprWithReplacements = do
                                      n <- choose (1,100)  -- randome size of the generated lambda macro expression
                                      (LamDef xs e) <-  (liftM2 LamDef (genListPairMacroExprClosed n) (genLamExpr' n))
                                      
                                      if xs == [] then return (LamDef xs e)  -- if there are no macros then it is not possible to insert a lambda expression defined in a macro
                                      else
                                            do
                                                let firstExpr = (snd.head) xs
                                                e' <- genReplacementInExpression firstExpr e
                                                return (LamDef xs e')
                                                     
                                        
-- genReplacementInExpression
--      This function is a generator for lambda macro expressions.
--      It takes as arguments two lamda expressions e1 and e2 and
--      randomly tries to insert e1 inside e2 such that e1 becomes
--      a sub-expression of e2. 
--      IMPORTANT: there is no guarancy about the number of times
--                 e1 is inserted in e2 as a sub-expression since the
--                 process is completely random. However, it is very likely 
--                 that e1 is in e2 at least once.
--                     
genReplacementInExpression :: LamExpr -> LamExpr -> Gen LamExpr

genReplacementInExpression e (LamApp e1 e2) = do
                                                n <- choose (0,3) :: Gen Int
                                                if n == 3 then return e  -- 1/4 probability that e replaces the current lambda expression
                                                else
                                                   do
                                                    e1' <- genReplacementInExpression e e1
                                                    e2' <- genReplacementInExpression e e2
                                                    return (LamApp e1' e2')
                                    
genReplacementInExpression e (LamAbs n e1) = do
                                                n <- choose (0,3) :: Gen Int
                                                if n == 3 then return e  -- 1/4 probability that e replaces the current lambda expression
                                                else
                                                  do
                                                    e1' <- genReplacementInExpression e e1
                                                    return (LamAbs n e1')
                                                    
genReplacementInExpression e (LamVar n) = do
                                                n <- choose (0,1) :: Gen Int
                                                if n == 1 then (return e) else return (LamVar  n)  -- 1/2 probability that e replaces the current lambda expression
                                                    
genReplacementInExpression e (LamMacro x) = do
                                                n <- choose (0,1) :: Gen Int
                                                if n == 1 then (return e) else return (LamMacro  x)  -- 1/2 probability that e replaces the current lambda expression
                                                  
                                                  
-- prop_SubExpressionReplaced
--      This function is equivalent to the function 'prop_unparseAndParse'
--      with the only exception that it uses the custom generator 'genLamMacroExprWithReplacements'
--      which makes it very likely that a generated lambda macro expression contains as sub-expression
--      a lambda expression defined by one of its macros.
--                                 
prop_unparseAndParse_SubExpressionReplaced :: Property            
                     
prop_unparseAndParse_SubExpressionReplaced =  forAll gen $ prop_unparseAndParse
                                           where
                                                gen = do
                                                        e <- genLamMacroExprWithReplacements
                                                        return (Closed e)
                                                        
                                                        
-- prop_prettyPrintMinimumNumberParenthesis
--      This function checks whether the 'prettyPrint' function
--      uses the least possible number of parenthesis so that 
--      the resulting string parses to the same abstract
--      syntax tree as the given input                      
--     
prop_prettyPrintMinimumNumberParenthesis :: LamMacroExpr -> Bool

prop_prettyPrintMinimumNumberParenthesis (LamDef xs e) = and $ map (\x -> (parseLamMacro x) /= (Just (LamDef [] e))) alternativesWithoutpars
                                                       where
                                                         prettyPrinted = prettyPrint (LamDef [] e)
                                                         alternativesWithoutpars = map (\(a,b) -> (deleteAt a . deleteAt b) prettyPrinted )(correspondingParethesis prettyPrinted)
                                                         deleteAt idx xs = lft ++ rgt
                                                                        where 
                                                                          (lft, (_:rgt)) = splitAt idx xs
 
 
-- correspondingParethesis
--      This function takes as input a string representing
--      a lambda expression and returns a list of integer pairs
--      that indicate the indexes of a pair of parenthesis that
--      match up.
--          %%EXAMPLE:
--              correspondingParethesis "(\\x1 -> x1)" = [(0,9)]
--                            
correspondingParethesis :: String -> [(Int,Int)]

correspondingParethesis xs = aux [] [] filteredElemIndexes
                           where
                             elemIndexes = zip xs [0..]
                             filteredElemIndexes = filter (\(a,b) -> a == '(' || a == ')') elemIndexes 
                             aux outs ps [] = outs
                             aux outs ps (('(',a):zs) = aux outs (('(',a):ps) zs
                             aux outs (('(',a):ps) ((')',b):zs) = aux ((a,b):outs) ps zs
                             
-------------------------------------------------------------------------------------------------------------------------------------------------
--                                                          +++ PROPERTIES TASK 3 +++                                                          --
-- prop_toCPSFromCPS
--      This function takes as argument a lambda expression e
--      and checks whether transforming it into continuation-
--      passing style and subsequenlty transforming it into
--      a standard lambda expression produces a lambda expression e'
--      such that e' is equal to e.
--
prop_toCPSFromCPS :: LamMacroExpr -> Bool

prop_toCPSFromCPS e = e == fromCps
                    where
                        toCps = cpsTransform e
                        fromCps = cpsUntransform toCps
                        
                        
-- isReducibleMacro 
--      This function checks whether a given lambda macro expression
--      is reducible. In other words, checks whether it contains a redex
--                       
isReducibleMacro :: LamMacroExpr -> Bool

isReducibleMacro (LamDef (x:xs) e) = True  -- if a macro definition is present then the expression is reducible
isReducibleMacro (LamDef [] e) = isReducible e  -- if there is no macro definitions then it must be checked whether there is a redex in the lambda expression e


-- isReducible
--      This function checks whether a given lambda expression
--      is reducible. In other words, checks whether it contains a redex.
--
isReducible :: LamExpr -> Bool

isReducible (LamVar _) = False
isReducible (LamMacro _) = False
isReducible (LamAbs n e) = isReducible e
isReducible (LamApp (LamAbs _ _) _) = True
isReducible (LamApp e1 e2) = isReducible e1 || isReducible e2


-- prop_numberSteps
--      This function checks whether the two following conditions
--      are satisfied when using the function 'numberSteps':
--
--          1) If a lamnda macro expression is reducible through a given
--             one-step reduction function in n steps such that n < upperbound
--             number of steps then the nth lambda macro expression must be non-reducible.
--
--          2) If a lambda macro expression is not reducible through a given
--             one-step reduction within the provided upperbound number of steps m then
--             the mth lambda macro expression must be reducible.
--
prop_numberSteps :: (LamMacroExpr -> Maybe LamMacroExpr) -> LamMacroExpr -> NonNegative Int -> Property

prop_numberSteps f e (NonNegative n) = n > 0 && n <= 10000 ==> case steps of
                                                                    Just x -> if x == 0 then not (isReducibleMacro e) else let Just reducedExpr = evalsUpToN !! (x-1) in not (isReducibleMacro reducedExpr)
                                                                    Nothing -> isReducibleMacro lastEval   -- the last lambda macro expression must be reducible
                                                                    where
                                                                        steps = numberSteps f e n
                                                                        evalsUpToN = (take (n+1). tail )(evalSteps f e)
                                                                        Just lastEval = (head . tail . reverse) evalsUpToN


-- prop_compareInnerOuterCps
--      This function checks whether the function 'compareInnerOuterCps' produces a 4-tuple
--      where the number of steps to reduce an expression e using inner reduction must be necessarily 
--      less than evaluating the same expression e transformed into cps. The same must hold for the
--      outermost reduction strategy. It takes a non negative integer as argument indicating the upper bound
--      for the number of possible reductions.
--                                                                  
prop_compareInnerOuterCps :: LamMacroExpr -> NonNegative Int -> Property

prop_compareInnerOuterCps e (NonNegative n) = n > 0 && n <= 100000 ==> (isLess n1 n3) && (isLess n2 n4)  -- constraining the number of steps to at most 100000
                                         where
                                            (n1,n2,n3,n4) = compareInnerOuter e n
                                            isLess :: Maybe Int -> Maybe Int -> Bool
                                            isLess (Just n1) (Just n2) = n1 <= n2
                                            isLess Nothing Nothing = True
                                            isLess (Just _) (Nothing) = True
                                            isLess _ _ = False
                                            
                                            
-- prop_compareInnerOuterChurchRosser
--      This function checks whether the function 'compareInnerOuterCps'
--      returns a 4-tuple (n1,n2,n3,n4) such that n1 and n2, n3 and n4 are
--      alpha equiquivalent. This must hold according to the Church-Rosser Theorem.
--                                             
prop_compareInnerOuterChurchRosser :: LamMacroExprClosedMacros -> NonNegative Int -> Property

prop_compareInnerOuterChurchRosser (Closed (e@(LamDef xs e1))) (NonNegative n) =  n > 0 && n <= 100000 && isJust (n1,n2,n3,n4) && ((length . nub ) macros == length macros) && (noSuccDefinitions exprMacros macros) ==> (isAlphaEquivalentMacro inner outer) && (isAlphaEquivalentMacro innerCps outerCps)  -- if it is not possible to reduce the expression or its continuation-passing style version with a given reduction evaluation then the test is discarded.
                                         where                                                                                                                                                                                                                                                                -- there cannot be duplicates
                                            (n1,n2,n3,n4) = compareInnerOuter e n                                                                                                                                                                                                                             -- there cannot be successive definitions of the macro names contained in previously defined lambda expressions  
                                            (macros, exprs) = unzip xs
                                            areClosed = and $ map isClosed exprs 
                                            isJust (Just _ , Just _, Just _, Just _) = True  -- checks whether the expression and its continuation-passing style are reduced withing the upperbound number of steps
                                            isJust _ = False  
                                            (Just n5, Just n6, Just n7, Just n8) = (n1,n2,n3,n4)          
                                            LamDef xs e' = cpsTransform e
                                            id = (LamAbs 1 (LamVar 1))
                                            eCps = (LamDef xs (LamApp e' id))                                            
                                            Just inner = ((take (n+2))(evalSteps innerRedn1 e)) !! n5
                                            Just outer = ((take (n+2))(evalSteps outerRedn1 e)) !! n6
                                            Just innerCps = ((take (n+2))(evalSteps innerRedn1 eCps)) !! n7
                                            Just outerCps = ((take (n+2))(evalSteps outerRedn1 eCps)) !! n8   
                                            exprMacros = (map allMacros exprs)  -- the macros inside each macro's definition
                                            
                                            -- This function checks whether there are no macros inside the lambda expressions
                                            -- defined by the macros which are defined successively on the list of macros.
                                            --
                                            noSuccDefinitions [] [] = True
                                            noSuccDefinitions (me:mes) (m:ms) | ms `intersect` me == [] = noSuccDefinitions mes ms
                                                                              | otherwise = False
     
                                            
-- isAlphaEquivalentMacro
--      This function checks whether two lambda macro expressions
--      are alpha equivalent.
--                                              
isAlphaEquivalentMacro :: LamMacroExpr -> LamMacroExpr -> Bool

isAlphaEquivalentMacro (LamDef xs e1) (LamDef ys e2) | length xs /= length ys = False
                                                     | otherwise = (macrosAlphaEquivalent) && (isAlphaEquivalent e1 e2)
                                                     where
                                                        (macros1, expres1) = unzip xs
                                                        (macros2, expres2) = unzip ys
                                                        ess = zip expres1 expres2
                                                        macrosAlphaEquivalent = and $  map (uncurry isAlphaEquivalent) ess
                                                       

-- isAlphaEquivalent
--      This function checks whether two lambda expressions
--      are alpha equivalent.
--
isAlphaEquivalent :: LamExpr -> LamExpr -> Bool

isAlphaEquivalent e1 e2 = isAlphaEquivalentAux possVars e1 e2
                        where
                            possVars = [1..] \\ ((allVariables e1) ++ (allVariables e2))  -- variables not already present in the two lambda expressions
                            
                            isAlphaEquivalentAux :: [Int] -> LamExpr -> LamExpr -> Bool
                            
                            isAlphaEquivalentAux ns (LamVar n1) (LamVar n2) = n1 == n2
                            isAlphaEquivalentAux ns (LamMacro xs) (LamMacro ys) = xs == ys
                            
                            isAlphaEquivalentAux (n:ns) (LamAbs n1 e1) (LamAbs n2 e2) | n1 == n2 = isAlphaEquivalentAux (n:ns) e1 e2
                                                                                      | otherwise = isAlphaEquivalentAux ns (LamAbs n (substVar e1 n1 (LamVar n))) (LamAbs n (substVar e2 n2 (LamVar n)))  -- both variables n1 and n2 are replaced with a new variable 
                                                                                      
                            isAlphaEquivalentAux ns (LamApp e1 e2) (LamApp e3 e4) = (isAlphaEquivalentAux ns e1 e3) && (isAlphaEquivalentAux ns e2 e4)
                            isAlphaEquivalentAux _ _ _ = False

separator = "--------------------------------------------------------------------------------------------------------------------------------------"

main :: IO ()
main = do
            ------------------------------------------------------------------------------------------------------------------------------------------------
            --                                              +++ TESTING 'movePosition' function +++                                                       --
            putStrLn separator
            putStrLn "\n+++ TESTING 'movePosition' FUNCTION +++\n"
            
            putStrLn "\n*** Testing in Forward direction***\n"
            quickCheck (asserts (movePosition (1,2) Forward) (1,3))
            
            putStrLn "\n*** Testing in Back direction***\n"
            quickCheck (asserts (movePosition (0,1) Back) (0,0))
            
            putStrLn "\n*** Testing in DownBack direction***\n"
            quickCheck (asserts (movePosition (1,1) DownBack) (2,0)) 
            
            putStrLn "\n*** Testing in Up direction***\n"
            quickCheck (asserts (movePosition (1,1) Up) (0,1)) 
            
            putStrLn "\n*** Testing in Down direction***\n"
            quickCheck (asserts (movePosition (1,1) Down) (2,1)) 
            
            putStrLn "\n*** Testing in DownForward direction***\n"
            quickCheck (asserts (movePosition (2,1) DownForward) (3,2)) 
            
            putStrLn "\n*** Testing in UpForward direction***\n"
            quickCheck (asserts (movePosition (2,1) UpForward) (1,2)) 
            
            putStrLn "\n*** Testing in UpBack direction***\n"
            quickCheck (asserts (movePosition (2,1) UpBack) (1,0)) 
            -------------------------------------------------------------------------------------------------------------------------------------------------
            --                                              +++ TESTING 'movePositiongrid' function +++                                                        --
            putStrLn separator
            putStrLn "\n+++ TESTING 'movePositionGrid' FUNCTION +++\n"
            let array = listArray ((0,0),(2,2)) ['A'..'I']
            
            putStrLn "\n*** Testing in Up direction ***\n"
            quickCheck (asserts (movePositionGrid (0,0) Up array) (Nothing))
            
            putStrLn "\n*** Testing in Back direction ***\n"
            quickCheck (asserts (movePositionGrid (0,0) Back array) (Nothing))
            
            putStrLn "\n*** Testing in Forward direction ***\n"
            quickCheck (asserts (movePositionGrid (1,1) Forward array) (Just ('F',(1,2)))) 
            
            putStrLn "\n*** Testing in Up direction ***\n"
            quickCheck (asserts (movePositionGrid (1,1) Up array) (Just ('B',(0,1)))) 
            
            putStrLn "\n*** Testing in Forward direction ***\n"
            quickCheck (asserts (movePositionGrid (2,2) Forward array) (Nothing)) 
            
            putStrLn "\n*** Testing in DownBack direction ***\n"
            quickCheck (asserts (movePositionGrid (2,0) DownBack array) (Nothing)) 
            
            putStrLn "\n*** Testing in DownForward direction ***\n"
            quickCheck (asserts (movePositionGrid (2,0) DownForward array) (Nothing)) 
            
            putStrLn "\n*** Testing in UpForward direction ***\n"
            quickCheck (asserts (movePositionGrid (0,2) UpForward array) (Nothing)) 
            
            putStrLn "\n*** Testing in UpBack direction ***\n"
            quickCheck (asserts (movePositionGrid (0,0) UpBack array) (Nothing))         
            -------------------------------------------------------------------------------------------------------------------------------------------------
            --                                              +++ TESTING 'isSatisfying' function +++                                                        --
            
            putStrLn separator
            putStrLn "\n+++ TESTING 'isSatisfying' FUNCTION +++\n"
            
            let grid = [['H', 'A', 'G', 'N', 'I', 'R', 'T', 'S', 'H'],
                        ['S', 'A', 'C', 'A', 'G', 'E', 'T', 'A', 'K'],
                        ['G', 'C', 'S', 'T', 'A', 'C', 'K', 'E', 'L'],
                        ['M', 'G', 'H', 'K', 'M', 'I', 'L', 'K', 'I'],
                        ['E', 'K', 'N', 'L', 'E', 'T', 'G', 'C', 'N'],
                        ['T', 'N', 'I', 'R', 'T', 'L', 'E', 'T', 'E'],
                        ['I', 'R', 'A', 'A', 'H', 'C', 'L', 'S', 'R'],
                        ['M', 'A', 'M', 'R', 'O', 'S', 'A', 'G', 'D'],
                        ['G', 'I', 'Z', 'K', 'D', 'D', 'N', 'R', 'G']]
                        
            let array = listArray ((0,0),(8,8)) (concat grid)
            
            putStrLn "\n*** Testing with 'AGNI' in position (0,1) direction Forward ***\n"
            quickCheck (asserts (isSatisfying (==) "AGNI" (0,1) array Forward) True)
            
            putStrLn "\n*** Testing with 'AGNI' in position (0,1) direction Up ***\n"
            quickCheck (asserts (isSatisfying (==) "AGNI" (0,1) array Up) False) 
            
            putStrLn "\n*** Testing with 'KOCEC' in position (8,3) direction UpForward ***\n"
            quickCheck (asserts (isSatisfying (==) "KOCEC" (8,3) array UpForward) True) 
            
            putStrLn "\n*** Testing with 'AKNNI' in position (2,4) direction DownBack ***\n"
            quickCheck (asserts (isSatisfying (==) "AKNNI" (2,4) array DownBack) True)
            
            putStrLn "\n*** Testing with 'AKNNI' in position (0,1) direction Forward ***\n"
            quickCheck (asserts (isSatisfying (==) "AKNNI" (0,1) array Forward) False) 
            
            ------------------------------------------------------------------------------------------------------------------------------------------------- 
             --                                              +++ TESTING 'satisfyingOrientations' function +++                                             --
            
            putStrLn separator
            putStrLn "\n+++ TESTING 'satisfyingOrientations' FUNCTION +++\n"
            
            putStrLn "\n***Testing with 'HASKELL' in position (0,0)***\n"
            quickCheck (prop_satisfyingOrientations (==) (0,0) array "HASKELL") 
            
            putStrLn "\n***Testing with 'HASKELL' in position (0,5)***\n"
            quickCheck (prop_satisfyingOrientations (==) (0,5) array "HASKELL") 
            
            putStrLn "\n***Testing with 'AA' in position (6,2)***\n"
            quickCheck (prop_satisfyingOrientations (==) (6,2) array "AA") 
            ------------------------------------------------------------------------------------------------------------------------------------------------- 
            --                                              +++ TESTING 'removeInfixes' function +++                                                       --
            
            putStrLn separator
            putStrLn "\n+++ TESTING 'removeInfixes' FUNCTION +++\n"
            
            putStrLn "\n***Testing Idempotence property***\n"
            quickCheckWith stdArgs {maxSuccess = 1000} (prop_removeInfixesIdempotence :: [String] -> Bool)
            
            putStrLn "\n***Testing 'Never Empty List' property***\n"
            quickCheckWith stdArgs {maxSuccess = 1000} (prop_removeInfixesNeverEmptyList :: (NonEmptyList String) -> Bool)
            -------------------------------------------------------------------------------------------------------------------------------------------------
             --                                              +++ TESTING 'removeReverse' function +++                                                      --
             
            putStrLn separator 
            putStrLn "\n+++ TESTING 'removeReverse' FUNCTION +++\n"
            
            putStrLn "\n***Testing Idempotence property***\n"
            quickCheckWith stdArgs {maxSuccess = 1000} (prop_removeReverseIdempotence :: [String] -> Bool)
            
            putStrLn "\n***Testing 'Never Empty List' property***\n"
            quickCheckWith stdArgs {maxSuccess = 1000} (prop_removeReverseNeverEmptyList :: (NonEmptyList String) -> Bool)
            
            -------------------------------------------------------------------------------------------------------------------------------------------------
             --                                              +++ TESTING 'isReverse' function +++                                                          --
            putStrLn separator 
            putStrLn "\n+++ TESTING 'isReverse' FUNCTION +++\n"
            
            putStrLn "\n***Testing commutative property***\n"
            quickCheckWith stdArgs {maxSuccess = 1000} (prop_isReverseCommutativity :: String -> String -> Bool)
            -------------------------------------------------------------------------------------------------------------------------------------------------
             --                                              +++ TESTING 'isInfixOfAny' function +++                                                       --
            putStrLn separator
            putStrLn "\n+++ TESTING 'isInfixOfAny' FUNCTION +++\n"
            putStrLn "\n***Testing property***\n"
            
            quickCheckWith stdArgs {maxSuccess = 1000} (prop_isInfixOfAny_removeInfixes :: String -> [String] -> Bool) 
            -------------------------------------------------------------------------------------------------------------------------------------------------
            --                                              +++ TESTING 'solveWordSearch' function +++                                                     --
            
            putStrLn separator
            putStrLn "\n+++ TESTING 'solveWordSearch' FUNCTION +++\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_solveWordSearchEmptyPuzzle
            
            let grid = [['H', 'A', 'G', 'N', 'I', 'R', 'T', 'S', 'H'],
                        ['S', 'A', 'C', 'A', 'G', 'E', 'T', 'A', 'K'],
                        ['G', 'C', 'S', 'T', 'A', 'C', 'K', 'E', 'L'],
                        ['M', 'G', 'H', 'K', 'M', 'I', 'L', 'K', 'I'],
                        ['E', 'K', 'N', 'L', 'E', 'T', 'G', 'C', 'N'],
                        ['T', 'N', 'I', 'R', 'T', 'L', 'E', 'T', 'E'],
                        ['I', 'R', 'A', 'A', 'H', 'C', 'L', 'S', 'R'],
                        ['M', 'A', 'M', 'R', 'O', 'S', 'A', 'G', 'D'],
                        ['G', 'I', 'Z', 'K', 'D', 'D', 'N', 'R', 'G']]
                        
            let actualSolution = [("HASKELL",Just((0,0),DownForward)),("STRING",Just((7,0),Back)),("STACK",Just((2,2),Forward)),("MAIN",Just((2,7),Up)),("METHOD",Just((4,3),Down))]
            let wordsPresent = ["HASKELL","STRING","MAIN","STACK","METHOD"]            
            let foundSolution = solveWordSearch wordsPresent grid
            
            putStrLn "\n***Testing a test case for 'solveWordSearch' function***\n"
            quickCheck ((sort foundSolution) == (sort $ actualSolution))
            
            putStrLn "\n***Testing createWordSearch solveWordSearch property***\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_createWordSearch_solveWordSearch
            
            
            -------------------------------------------------------------------------------------------------------------------------------------------------
             --                                              +++ TESTING 'createWordSearch' function +++                                                   --
             
            putStrLn separator
            putStrLn "\n+++ TESTING 'createWordSearch' FUNCTION +++\n"
            
            putStrLn "\n***Testing density property***\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_createWordSearchDensity
            
            putStrLn "\n***Testing exactly once property***\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_createWordSearchExactlyOnce
            
            putStrLn "\n***Testing solvable property***\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_createWordSearchSolvable
            
            putStrLn "\n***Testing square grid property***\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_createWordSearchSquare
            
            putStrLn "\n***Testing no empties property***\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_createWordSearchNoEmpties
            
            putStrLn "\n***Testing set of characters property***\n"
            quickCheckWith stdArgs {maxSuccess = 100} prop_createWordSearchSetCharacters
                       
            
            
            -------------------------------------------------------------------------------------------------------------------------------------------------
            --                                              +++ TESTING 'TASK 2 +++                                                                        --
            putStrLn separator
            putStrLn "\n+++ TESTING 'prettyPrint' and 'parseLamMacro' FUNCTIONS +++\n"
            
            putStrLn "\n***Testing 'prettyPrint' minimum number parenthesis property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} prop_prettyPrintMinimumNumberParenthesis
            
            putStrLn "\n***Testing unparsing and parsing of lambda macro expressions***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} prop_unparseAndParse
            
            putStrLn "\n***Testing unparsing and parsing of lambda macro expressions with replacements property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} prop_unparseAndParse_SubExpressionReplaced
            
            putStrLn "\n***Testing undefined lambda macro expressions parsing property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} (prop_parseLamMacroUndefined)
            
            let mulTestCasesPrettyPrint = [  
                                            (prettyPrint (LamDef [] (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 1 (LamVar 1))))
                                            == "(\\x1 -> x1) \\x1 -> x1"),
                                            (prettyPrint (LamDef [] (LamAbs 1 (LamApp (LamVar 1) (LamAbs 1 (LamVar 1)))))
                                            == "\\x1 -> x1 \\x1 -> x1"),
                                            (prettyPrint (LamDef [ ("F", LamAbs 1 (LamVar 1) ) ] (LamAbs 2 (LamApp (LamVar 2) (LamMacro "F"))))
                                            == "def F = \\x1 -> x1 in \\x2 -> x2 F"),
                                            (prettyPrint (LamDef [ ("F", LamAbs 1 (LamVar 1) ) ] (LamAbs 2 (LamApp (LamAbs 1 (LamVar 1)) (LamVar 2))))
                                            == "def F = \\x1 -> x1 in \\x2 -> F x2"),
                                            (prettyPrint (LamDef [ ("G", LamAbs 1 (LamAbs 2 (LamVar 1))), ("F", LamAbs 1 (LamAbs 2 (LamVar 2))) ] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamMacro "G") (LamApp (LamApp (LamMacro "F") (LamVar 2)) (LamVar 1))) (LamVar 2)))))
                                            == "def G = \\x1 -> \\x2 -> x1 in def F = \\x1 -> \\x2 -> x2 in \\x1 -> \\x2 -> G (F x2 x1) x2"),
                                            (prettyPrint (LamDef [ ("G", LamAbs 1 (LamAbs 2 (LamVar 1)))] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamAbs 1 (LamAbs 2 (LamVar 1))) (LamApp (LamApp (LamAbs 1 (LamAbs 2 (LamVar 2))) (LamVar 2)) (LamVar 1))) (LamVar 2)))))
                                            == "def G = \\x1 -> \\x2 -> x1 in \\x1 -> \\x2 -> G ((\\x1 -> \\x2 -> x2) x2 x1) x2"),
                                            (prettyPrint (LamDef [ ("G", LamAbs 1 (LamAbs 2 (LamVar 1)))] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamAbs 1 (LamAbs 2 (LamVar 1))) (LamApp (LamAbs 2 (LamVar 2)) (LamVar 1))) (LamVar 2)))))
                                            == "def G = \\x1 -> \\x2 -> x1 in \\x1 -> \\x2 -> G ((\\x2 -> x2) x1) x2"),
                                            (prettyPrint (LamDef [ ("G", LamAbs 1 (LamAbs 2 (LamVar 1)))] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamAbs 1 (LamAbs 2 (LamVar 1))) (LamVar 1)) (LamVar 2)))))
                                            == "def G = \\x1 -> \\x2 -> x1 in \\x1 -> \\x2 -> G x1 x2"),
                                            (prettyPrint (LamDef [] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamAbs 1 (LamAbs 2 (LamVar 1))) (LamVar 1)) (LamVar 2)))))
                                            == "\\x1 -> \\x2 -> (\\x1 -> \\x2 -> x1) x1 x2"),
                                            (prettyPrint (LamDef [] (LamAbs 1 (LamAbs 2 (LamApp (LamAbs 2 (LamVar 1)) (LamVar 2)))))
                                            == "\\x1 -> \\x2 -> (\\x2 -> x1) x2"),
                                            (prettyPrint (LamDef [] (LamAbs 1 (LamAbs 2 (LamVar 1))))
                                            == "\\x1 -> \\x2 -> x1"),
                                            (prettyPrint (LamDef [ ("G", LamVar 1) ] (LamVar 1))
                                            == "def G = x1 in G"),   
                                            (prettyPrint (LamDef [] (LamApp (LamVar 2) (LamVar 1)))
                                            == "x2 x1"),
                                            (prettyPrint (LamDef [] (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 1 (LamVar 1))))
                                            == "(\\x1 -> x1) \\x1 -> x1"),
                                            (prettyPrint (LamDef [] (LamAbs 1 (LamApp (LamVar 1) (LamAbs 1 (LamVar 1)))))
                                            == "\\x1 -> x1 \\x1 -> x1"),
                                            (prettyPrint (LamDef [] (LamApp (LamAbs 1 (LamVar 1)) (LamVar 1)))
                                            == "(\\x1 -> x1) x1"),
                                            (prettyPrint (LamDef [] (LamApp (LamAbs 3 (LamVar 3)) (LamAbs 3 (LamVar 3))))
                                            == "(\\x3 -> x3) \\x3 -> x3"),
                                            (prettyPrint (LamDef [] (LamAbs 1 (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 1 (LamVar 1)))))
                                            == "\\x1 -> (\\x1 -> x1) \\x1 -> x1"),
                                            (prettyPrint (LamDef [] (LamApp (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0)))) (LamVar 0)))
                                            == "(\\x0 -> \\x1 -> x1 x0) x0"),
                                            (prettyPrint (LamDef [] (LamApp (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0)))) (LamAbs 1 (LamVar 0))))
                                            == "(\\x0 -> \\x1 -> x1 x0) \\x1 -> x0"),
                                            (prettyPrint (LamDef [] (LamApp (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0)))) (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0))))))
                                            == "(\\x0 -> \\x1 -> x1 x0) \\x0 -> \\x1 -> x1 x0"),
                                            (prettyPrint (LamDef [ ("G", LamAbs 1 (LamAbs 2 (LamVar 1))), ("F", LamAbs 2 (LamVar 1)) ] (LamAbs 1 (LamAbs 1 (LamAbs 2 (LamVar 1)))))
                                            == "def G = \\x1 -> \\x2 -> x1 in def F = \\x2 -> x1 in \\x1 -> G")
                                          ]
                                          
            putStrLn "\n***Testing multiple test cases 'prettyPrint' function***\n"
            sequence $ map quickCheck mulTestCasesPrettyPrint
            
            
            putStrLn "\n***Testing a test case for 'parseLamMacro' function***\n"
            quickCheck (asserts (parseLamMacro "x1 (x2 x3)") (Just (LamDef [] (LamApp (LamVar 1) (LamApp(LamVar 2) (LamVar 3))))))
            
            putStrLn "\n***Testing a test case for 'parseLamMacro' function***\n"
            quickCheck (asserts (parseLamMacro "x1 x2 F") (Just (LamDef [] (LamApp (LamApp (LamVar 1)(LamVar 2)) (LamMacro "F")))))
            
            putStrLn "\n***Testing a test case for 'parseLamMacro' function***\n"
            quickCheck (asserts (parseLamMacro "def F = \\x1-> x1 in \\x2 -> x2 F") (Just (LamDef [ ("F", LamAbs 1 (LamVar 1) ) ](LamAbs 2 (LamApp (LamVar 2) (LamMacro"F"))))))
            
            putStrLn "\n***Testing a test case for 'parseLamMacro' function***\n"
            quickCheck (asserts (parseLamMacro "def F = \\x1 -> x1 (def G = \\x1 -> x1 in x1) in \\x2 -> x2") (Nothing))
            
            putStrLn "\n***Testing a test case for 'parseLamMacro' function***\n"
            quickCheck (asserts (parseLamMacro "def F = \\x1 -> x1 in def F = \\x2 -> x2 x1 in x1") (Nothing))
            
            putStrLn "\n***Testing a test case for 'parseLamMacro' function***\n"
            quickCheck (asserts (parseLamMacro "def F = x1 in F") (Nothing))
            
            let mulTestCasesParseLamMacro = [
                                (parseLamMacro "(\\x1 -> x1) \\x1 -> x1" 
                                == Just (LamDef [] (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 1 (LamVar 1))))),
                                (parseLamMacro "\\x1 -> x1 \\x1 -> x1"
                                == Just (LamDef [] (LamAbs 1 (LamApp (LamVar 1) (LamAbs 1 (LamVar 1)))))),
                                (parseLamMacro "def F = \\x1 -> x1 in \\x2 -> x2 F"
                                == Just (LamDef [ ("F", LamAbs 1 (LamVar 1) ) ] (LamAbs 2 (LamApp (LamVar 2) (LamMacro "F"))))),
                                (parseLamMacro "def F = \\x1 -> x1 in \\x2 -> F x2"
                                == Just (LamDef [ ("F",LamAbs 1 (LamVar 1)) ] (LamAbs 2 (LamApp (LamMacro "F") (LamVar 2))))),
                                (parseLamMacro "def G = \\x1 -> \\x2 -> x1 in def F = \\x1 -> \\x2 -> x2 in \\x1 -> \\x2 -> G (F x2 x1) x2"
                                == Just (LamDef [ ("G", LamAbs 1 (LamAbs 2 (LamVar 1))), ("F", LamAbs 1 (LamAbs 2 (LamVar 2))) ] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamMacro "G") (LamApp (LamApp (LamMacro "F") (LamVar 2)) (LamVar 1))) (LamVar 2)))))),
                                (parseLamMacro "def G = \\x1 -> \\x2 -> x1 in \\x1 -> \\x2 -> G ((\\x1 -> \\x2 -> x2) x2 x1) x2"
                                == Just (LamDef [("G",LamAbs 1 (LamAbs 2 (LamVar 1)))] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamMacro "G") (LamApp (LamApp (LamAbs 1 (LamAbs 2 (LamVar 2))) (LamVar 2)) (LamVar 1))) (LamVar 2)))))),
                                (parseLamMacro "def G = \\x1 -> \\x2 -> x1 in \\x1 -> \\x2 -> G ((\\x2 -> x2) x1) x2"
                                == Just (LamDef [("G",LamAbs 1 (LamAbs 2 (LamVar 1)))] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamMacro "G") (LamApp (LamAbs 2 (LamVar 2)) (LamVar 1))) (LamVar 2)))))),
                                (parseLamMacro "def G = \\x1 -> \\x2 -> x1 in \\x1 -> \\x2 -> G x1 x2"
                                == Just (LamDef [ ("G",LamAbs 1 (LamAbs 2 (LamVar 1)))] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamMacro "G") (LamVar 1)) (LamVar 2)))))),
                                (parseLamMacro "\\x1 -> \\x2 -> (\\x1 -> \\x2 -> x1) x1 x2"
                                == Just (LamDef [] (LamAbs 1 (LamAbs 2 (LamApp (LamApp (LamAbs 1 (LamAbs 2 (LamVar 1))) (LamVar 1)) (LamVar 2)))))),
                                (parseLamMacro "\\x1 -> \\x2 -> (\\x2 -> x1) x2"
                                == Just (LamDef [] (LamAbs 1 (LamAbs 2 (LamApp (LamAbs 2 (LamVar 1)) (LamVar 2)))))),
                                (parseLamMacro "\\x1 -> \\x2 -> x1"
                                == Just (LamDef [] (LamAbs 1 (LamAbs 2 (LamVar 1))))),
                                (parseLamMacro "def G = x1 in G"
                                == Nothing),   
                                (parseLamMacro "x2 x1"
                                == Just (LamDef [] (LamApp (LamVar 2) (LamVar 1)))),
                                (parseLamMacro "(\\x1 -> x1) \\x1 -> x1"
                                == Just (LamDef [] (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 1 (LamVar 1))))),
                                (parseLamMacro "\\x1 -> x1 \\x1 -> x1"
                                == Just (LamDef [] (LamAbs 1 (LamApp (LamVar 1) (LamAbs 1 (LamVar 1)))))),
                                (parseLamMacro "(\\x1 -> x1) x1"
                                == Just (LamDef [] (LamApp (LamAbs 1 (LamVar 1)) (LamVar 1)))),
                                (parseLamMacro "(\\x3 -> x3) \\x3 -> x3"
                                == Just (LamDef [] (LamApp (LamAbs 3 (LamVar 3)) (LamAbs 3 (LamVar 3))))),
                                (parseLamMacro "\\x1 -> (\\x1 -> x1) \\x1 -> x1"
                                == Just (LamDef [] (LamAbs 1 (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 1 (LamVar 1)))))),
                                (parseLamMacro "(\\x0 -> \\x1 -> x1 x0) x0"
                                == Just (LamDef [] (LamApp (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0)))) (LamVar 0)))),
                                (parseLamMacro "(\\x0 -> \\x1 -> x1 x0) \\x1 -> x0"
                                == Just (LamDef [] (LamApp (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0)))) (LamAbs 1 (LamVar 0))))),
                                (parseLamMacro "(\\x0 -> \\x1 -> x1 x0) \\x0 -> \\x1 -> x1 x0"
                                == Just (LamDef [] (LamApp (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0)))) (LamAbs 0 (LamAbs 1 (LamApp (LamVar 1) (LamVar 0))))))),
                                (parseLamMacro "def G = \\x1 -> \\x2 -> x1 in def F = \\x2 -> x1 in \\x1 -> G"
                                == Nothing)
                              ]
            
            putStrLn "\n***Testing multiple test cases for 'parseLamMacro'***\n"
            sequence $ map quickCheck mulTestCasesParseLamMacro

            
            
            let expr1 = LamDef [("X",(LamApp (LamAbs 1 (LamVar 1)) (LamAbs 2 (LamVar 2)))), ("Y", ((LamAbs 1 (LamVar 1))))] (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 2 (LamVar 2)))
            let expr2 = LamDef [("X",(LamApp (LamAbs 1 (LamVar 1)) (LamAbs 2 (LamVar 2)))), ("Y", ((LamAbs 1 (LamVar 1))))] (LamMacro "X")
            let expr3 = LamDef [("X", (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 2 (LamVar 2)))), ("Y", (LamAbs 1 (LamVar 1)))] (LamApp (LamAbs 1 (LamVar 1)) (LamAbs 2 (LamVar 2)))
            let expr4 = LamDef [("X",(LamApp (LamAbs 1 (LamVar 1)) (LamAbs 2 (LamVar 2)))), ("Y", (LamAbs 1 (LamVar 1)))] (LamMacro "X")
            let expr1Printed = prettyPrint expr1
            let expr3Printed = prettyPrint expr3
            let Just expr1Parsed = parseLamMacro expr1Printed
            let Just expr3Parsed = parseLamMacro expr3Printed
            
            putStrLn "\n***Testing that first macro is replaced first***\n"
            quickCheck  (asserts expr1Parsed expr2)
            
            putStrLn "\n***Testing that largest macro is replaced first***\n"
            quickCheck  (asserts expr3Parsed expr4)
            
            -------------------------------------------------------------------------------------------------------------------------------------------------
            --                                              +++ TESTING TASK 3 +++                                                                         --
            putStrLn separator
            putStrLn "\n+++ TESTING 'cpsTransform' FUNCTION +++\n"
            
            putStrLn "\n***Testing to CPS from CPS property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} prop_toCPSFromCPS
            
            let Just parsed1 = parseLamMacro "x1 x2"
            let Just parsed2 = parseLamMacro "def F = \\x1 -> x1 in x2"
            let Just parsed3 = parseLamMacro "def F = \\x1 -> x1 in F"
            let Just parsed4 = parseLamMacro "def F = \\x1 -> x1 in F F"
            let Just parsed5 = parseLamMacro "\\x3 -> (\\x6 -> x6 x1) (\\x4 -> (\\x7 -> x7 x2) (\\x5 -> x4 x5 x3))"
            let Just parsed6 = parseLamMacro "def F = \\x3 -> x3 (\\x1 -> (\\x4 -> x4 x1)) in (\\x5 -> x5 x2)"
            let Just parsed7 = parseLamMacro "def F = \\x2 -> x2 (\\x1 -> (\\x3 -> x3 x1)) in F"
            let Just parsed8 = parseLamMacro "def F = \\x2 -> x2 (\\x1 -> (\\x3 -> x3 x1)) in \\x4 -> F (\\x5 -> F (\\x6 -> x5 x6 x4))"
            
            putStrLn "\n***Testing a test case for 'cpsTransform' function***\n"
            quickCheck (isAlphaEquivalentMacro (cpsTransform parsed1) (parsed5))
            
            putStrLn "\n***Testing a test case for 'cpsTransform' function***\n"
            quickCheck (isAlphaEquivalentMacro (cpsTransform parsed2) (parsed6))
            
            putStrLn "\n***Testing a test case for 'cpsTransform' function***\n"
            quickCheck (isAlphaEquivalentMacro (cpsTransform parsed3) (parsed7))
            
            putStrLn "\n***Testing a test case for 'cpsTransform' function***\n"
            quickCheck (isAlphaEquivalentMacro (cpsTransform parsed4) (parsed8))
            
            
            putStrLn "\n***Testing macro substitutions***\n"
            quickCheck (asserts (substMacro (LamMacro "X") "X" (LamVar 1)) (LamVar 1))
            
            putStrLn "\n***Testing macro substitutions***\n"
            quickCheck (asserts (substMacro (LamMacro "X") "Y" (LamVar 1)) (LamMacro "X")) 
            
            putStrLn "\n***Testing macro substitutions***\n"
            quickCheck (asserts (substMacro (LamVar 1 ) "X" (LamAbs 1 (LamVar 2))) (LamVar 1)) 
            
            putStrLn "\n***Testing macro substitutions***\n"
            quickCheck (asserts (substMacro (LamAbs 1 (LamMacro "X")) "X" (LamVar 1)) (LamAbs 1 (LamVar 1))) 
            
            putStrLn "\n***Testing macro substitutions***\n"
            quickCheck (asserts (substMacro (LamApp (LamMacro "X")(LamVar 1)) "X" (LamVar 1)) (LamApp (LamVar 1)(LamVar 1))) 
            
            let Just parsed1 = parseLamMacro "(\\x1 -> x1 x2)"
            let Just parsed2 = parseLamMacro "def F = \\x1 -> x1 in F"
            let Just parsed3 = parseLamMacro "(\\x1 -> x1) (\\x2 -> x2)"
            let Just parsed4 = parseLamMacro "(\\x1 -> x1 x1)(\\x1 -> x1 x1)"
            let Just parsed5 = parseLamMacro "def ID = \\x1 -> x1 in def FST = (\\x1 -> \\x2 -> x1) in FST x3 (ID x4)"
            let Just parsed6 = parseLamMacro "def FST = (\\x1 -> \\x2 -> x1) in FST x3 ((\\x1 ->x1) x4)"
            let Just parsed7 = parseLamMacro "def ID = \\x1 -> x1 in def SND = (\\x1 -> \\x2 -> x2) in SND ((\\x1 -> x1 x1) (\\x1 -> x1 x1)) ID"
            
            putStrLn separator
            putStrLn "\n+++ TESTING 'innerRedn1', 'outerRedn1' and 'compareInnerOuter' FUNCTION +++\n"
            
            putStrLn "\n***Testing a test case for 'compareInnerOuter' function***\n"
            quickCheck (asserts (compareInnerOuter parsed1 10) (Just 0, Just 0, Just 6, Just 6))
            
            putStrLn "\n***Testing a test case for 'compareInnerOuter' function***\n"
            quickCheck (asserts (compareInnerOuter parsed2 10) (Just 1, Just 1,Just 3,Just 3))
            
            putStrLn "\n***Testing a test case for 'compareInnerOuter' function***\n"
            quickCheck (asserts (compareInnerOuter parsed3 10) (Just 1,Just 1,Just 8,Just 8))
            
            putStrLn "\n***Testing a test case for 'compareInnerOuter' function***\n"
            quickCheck (asserts (compareInnerOuter parsed4 100) (Nothing,Nothing,Nothing,Nothing))
            
            putStrLn "\n***Testing a test case for 'compareInnerOuter' function***\n"
            quickCheck (asserts (compareInnerOuter parsed5 30) (Just 4,Just 4,Just 22,Just 22))
            
            putStrLn "\n***Testing a test case for compareInnerOuter***\n"
            quickCheck (asserts (compareInnerOuter parsed6 30) (Just 4,Just 3,Just 21,Just 21))
            
            putStrLn "\n***Testing a test case for compareInnerOuter***\n"
            quickCheck (asserts (compareInnerOuter parsed7 1000) (Nothing,Just 4,Nothing,Nothing))
            
            putStrLn "\n***Testing number steps with innerRedn1 property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} (prop_numberSteps innerRedn1) 
            
            putStrLn "\n***Testing number steps with outerRedn1 property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} (prop_numberSteps outerRedn1)
            
            putStrLn "\n***Testing compareInnerOuterCps property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} (prop_compareInnerOuterCps)
            
            putStrLn "\n***Testing Church-Rosser property***\n"
            quickCheckWith stdArgs {maxSuccess = 100000} (prop_compareInnerOuterChurchRosser)
      
            
            
            
wordDataBase = ["ABANDON", "ABILITY", "ABLE", "ABORTION", "ABOUT", "ABOVE", "ABROAD", "ABSENCE", "ABSOLUTE", "ABSOLUTELY", "ABSORB", "ABUSE", "ACADEMIC", "ACCEPT", "ACCESS", 
                    "ACCIDENT", "ACCOMPANY", "ACCOMPLISH", "ACCORDING", "ACCOUNT", "ACCURATE", "ACCUSE", "ACHIEVE", "ACHIEVEMENT", "ACID", "ACKNOWLEDGE", "ACQUIRE", "ACROSS", "ACT", "ACTION", 
                    "ACTIVE", "ACTIVIST", "ACTIVITY", "ACTOR", "ACTRESS", "ACTUAL", "ACTUALLY", "AD", "ADAPT", "ADD", "ADDITION", "ADDITIONAL", "ADDRESS", "ADEQUATE", "ADJUST", "ADJUSTMENT", 
                    "ADMINISTRATION", "ADMINISTRATOR", "ADMIRE", "ADMISSION", "ADMIT", "ADOLESCENT", "ADOPT", "ADULT", "ADVANCE", "ADVANCED", "ADVANTAGE", "ADVENTURE", "ADVERTISING", "ADVICE", 
                    "ADVISE", "ADVISER", "ADVOCATE", "AFFAIR", "AFFECT", "AFFORD", "AFRAID", "AFRICAN", "AFRICAN-AMERICAN", "AFTER", "AFTERNOON", "AGAIN", "AGAINST", "AGE", "AGENCY", "AGENDA", 
                    "AGENT", "AGGRESSIVE", "AGO", "AGREE", "AGREEMENT", "AGRICULTURAL", "AH", "AHEAD", "AID", "AIDE", "AIDS", "AIM", "AIR", "AIRCRAFT", "AIRLINE", "AIRPORT", "ALBUM", "ALCOHOL", 
                    "ALIVE", "ALL", "ALLIANCE", "ALLOW", "ALLY", "ALMOST", "ALONE", "ALONG", "ALREADY", "ALSO", "ALTER", "ALTERNATIVE", "ALTHOUGH", "ALWAYS", "AM", "AMAZING", "AMERICAN", "AMONG", 
                    "AMOUNT", "ANALYSIS", "ANALYST", "ANALYZE", "ANCIENT", "AND", "ANGER", "ANGLE", "ANGRY", "ANIMAL", "ANNIVERSARY", "ANNOUNCE", "ANNUAL", "ANOTHER", "ANSWER", "ANTICIPATE", 
                    "ANXIETY", "ANY", "ANYBODY", "ANYMORE", "ANYONE", "ANYTHING", "ANYWAY", "ANYWHERE", "APART", "APARTMENT", "APPARENT", "APPARENTLY", "APPEAL", "APPEAR", "APPEARANCE", "APPLE", 
                    "APPLICATION", "APPLY", "APPOINT", "APPOINTMENT", "APPRECIATE", "APPROACH", "APPROPRIATE", "APPROVAL", "APPROVE", "APPROXIMATELY", "ARAB", "ARCHITECT", "AREA", "ARGUE", "ARGUMENT", 
                    "ARISE", "ARM", "ARMED", "ARMY", "AROUND", "ARRANGE", "ARRANGEMENT", "ARREST", "ARRIVAL", "ARRIVE", "ART", "ARTICLE", "ARTIST", "ARTISTIC", "AS", "ASIAN", "ASIDE", "ASK", "ASLEEP", 
                    "ASPECT", "ASSAULT", "ASSERT", "ASSESS", "ASSESSMENT", "ASSET", "ASSIGN", "ASSIGNMENT", "ASSIST", "ASSISTANCE", "ASSISTANT", "ASSOCIATE", "ASSOCIATION", "ASSUME", "ASSUMPTION", 
                    "ASSURE", "AT", "ATHLETE", "ATHLETIC", "ATMOSPHERE", "ATTACH", "ATTACK", "ATTEMPT", "ATTEND", "ATTENTION", "ATTITUDE", "ATTORNEY", "ATTRACT", "ATTRACTIVE", "ATTRIBUTE", "AUDIENCE", 
                    "AUTHOR", "AUTHORITY", "AUTO", "AVAILABLE", "AVERAGE", "AVOID", "AWARD", "AWARE", "AWARENESS", "AWAY", "AWFUL", "BABY", "BACK", "BACKGROUND", "BAD", "BADLY", "BAG", "BAKE", 
                    "BALANCE", "BALL", "BAN", "BAND", "BANK", "BAR", "BARELY", "BARREL", "BARRIER", "BASE", "BASEBALL", "BASIC", "BASICALLY", "BASIS", "BASKET", "BASKETBALL", "BATHROOM", "BATTERY", 
                    "BATTLE", "BE", "BEACH", "BEAN", "BEAR", "BEAT", "BEAUTIFUL", "BEAUTY", "BECAUSE", "BECOME", "BED", "BEDROOM", "BEER", "BEFORE", "BEGIN", "BEGINNING", "BEHAVIOR", "BEHIND", 
                    "BEING", "BELIEF", "BELIEVE", "BELL", "BELONG", "BELOW", "BELT", "BENCH", "BEND", "BENEATH", "BENEFIT", "BESIDE", "BESIDES", "BEST", "BET", "BETTER", "BETWEEN", "BEYOND", "BIBLE", 
                    "BIG", "BIKE", "BILL", "BILLION", "BIND", "BIOLOGICAL", "BIRD", "BIRTH", "BIRTHDAY", "BIT", "BITE", "BLACK", "BLADE", "BLAME", "BLANKET", "BLIND", "BLOCK", "BLOOD", "BLOW", "BLUE", 
                    "BOARD", "BOAT", "BODY", "BOMB", "BOMBING", "BOND", "BONE", "BOOK", "BOOM", "BOOT", "BORDER", "BORN", "BORROW", "BOSS", "BOTH", "BOTHER", "BOTTLE", "BOTTOM", "BOUNDARY", "BOWL", 
                    "BOX", "BOY", "BOYFRIEND", "BRAIN", "BRANCH", "BRAND", "BREAD", "BREAK", "BREAKFAST", "BREAST", "BREATH", "BREATHE", "BRICK", "BRIDGE", "BRIEF", "BRIEFLY", "BRIGHT", "BRILLIANT", 
                    "BRING", "BRITISH", "BROAD", "BROKEN", "BROTHER", "BROWN", "BRUSH", "BUCK", "BUDGET", "BUILD", "BUILDING", "BULLET", "BUNCH", "BURDEN", "BURN", "BURY", "BUS", "BUSINESS", "BUSY", 
                    "BUT", "BUTTER", "BUTTON", "BUY", "BUYER", "BY", "CABIN", "CABINET", "CABLE", "CAKE", "CALCULATE", "CALL", "CAMERA", "CAMP", "CAMPAIGN", "CAMPUS", "CAN", "CANADIAN", "CANCER", 
                    "CANDIDATE", "CAP", "CAPABILITY", "CAPABLE", "CAPACITY", "CAPITAL", "CAPTAIN", "CAPTURE", "CAR", "CARBON", "CARD", "CARE", "CAREER", "CAREFUL", "CAREFULLY", "CARRIER", "CARRY", 
                    "CASE", "CASH", "CAST", "CAT", "CATCH", "CATEGORY", "CATHOLIC", "CAUSE", "CEILING", "CELEBRATE", "CELEBRATION", "CELEBRITY", "CELL", "CENTER", "CENTRAL", "CENTURY", "CEO", 
                    "CEREMONY", "CERTAIN", "CERTAINLY", "CHAIN", "CHAIR", "CHAIRMAN", "CHALLENGE", "CHAMBER", "CHAMPION", "CHAMPIONSHIP", "CHANCE", "CHANGE", "CHANGING", "CHANNEL", "CHAPTER", 
                    "CHARACTER", "CHARACTERISTIC", "CHARACTERIZE", "CHARGE", "CHARITY", "CHART", "CHASE", "CHEAP", "CHECK", "CHEEK", "CHEESE", "CHEF", "CHEMICAL", "CHEST", "CHICKEN", "CHIEF", "CHILD", 
                    "CHILDHOOD", "CHINESE", "CHIP", "CHOCOLATE", "CHOICE", "CHOLESTEROL", "CHOOSE", "CHRISTIAN", "CHRISTMAS", "CHURCH", "CIGARETTE", "CIRCLE", "CIRCUMSTANCE", "CITE", "CITIZEN", 
                    "CITY", "CIVIL", "CIVILIAN", "CLAIM", "CLASS", "CLASSIC", "CLASSROOM", "CLEAN", "CLEAR", "CLEARLY", "CLIENT", "CLIMATE", "CLIMB", "CLINIC", "CLINICAL", "CLOCK", "CLOSE", "CLOSELY", 
                    "CLOSER", "CLOTHES", "CLOTHING", "CLOUD", "CLUB", "CLUE", "CLUSTER", "COACH", "COAL", "COALITION", "COAST", "COAT", "CODE", "COFFEE", "COGNITIVE", "COLD", "COLLAPSE", "COLLEAGUE", 
                    "COLLECT", "COLLECTION", "COLLECTIVE", "COLLEGE", "COLONIAL", "COLOR", "COLUMN", "COMBINATION", "COMBINE", "COME", "COMEDY", "COMFORT", "COMFORTABLE", "COMMAND", "COMMANDER", 
                    "COMMENT", "COMMERCIAL", "COMMISSION", "COMMIT", "COMMITMENT", "COMMITTEE", "COMMON", "COMMUNICATE", "COMMUNICATION", "COMMUNITY", "COMPANY", "COMPARE", "COMPARISON", "COMPETE", 
                    "COMPETITION", "COMPETITIVE", "COMPETITOR", "COMPLAIN", "COMPLAINT", "COMPLETE", "COMPLETELY", "COMPLEX", "COMPLICATED", "COMPONENT", "COMPOSE", "COMPOSITION", "COMPREHENSIVE", 
                    "COMPUTER", "CONCENTRATE", "CONCENTRATION", "CONCEPT", "CONCERN", "CONCERNED", "CONCERT", "CONCLUDE", "CONCLUSION", "CONCRETE", "CONDITION", "CONDUCT", "CONFERENCE", "CONFIDENCE", 
                    "CONFIDENT", "CONFIRM", "CONFLICT", "CONFRONT", "CONFUSION", "CONGRESS", "CONGRESSIONAL", "CONNECT", "CONNECTION", "CONSCIOUSNESS", "CONSENSUS", "CONSEQUENCE", "CONSERVATIVE", 
                    "CONSIDER", "CONSIDERABLE", "CONSIDERATION", "CONSIST", "CONSISTENT", "CONSTANT", "CONSTANTLY", "CONSTITUTE", "CONSTITUTIONAL", "CONSTRUCT", "CONSTRUCTION", "CONSULTANT", 
                    "CONSUME", "CONSUMER", "CONSUMPTION", "CONTACT", "CONTAIN", "CONTAINER", "CONTEMPORARY", "CONTENT", "CONTEST", "CONTEXT", "CONTINUE", "CONTINUED", "CONTRACT", "CONTRAST", 
                    "CONTRIBUTE", "CONTRIBUTION", "CONTROL", "CONTROVERSIAL", "CONTROVERSY", "CONVENTION", "CONVENTIONAL", "CONVERSATION", "CONVERT", "CONVICTION", "CONVINCE", "COOK", "COOKIE", 
                    "COOKING", "COOL", "COOPERATION", "COP", "COPE", "COPY", "CORE", "CORN", "CORNER", "CORPORATE", "CORPORATION", "CORRECT", "CORRESPONDENT", "COST", "COTTON", "COUCH", "COULD", 
                    "COUNCIL", "COUNSELOR", "COUNT", "COUNTER", "COUNTRY", "COUNTY", "COUPLE", "COURAGE", "COURSE", "COURT", "COUSIN", "COVER", "COVERAGE", "COW", "CRACK", "CRAFT", "CRASH", "CRAZY", 
                    "CREAM", "CREATE", "CREATION", "CREATIVE", "CREATURE", "CREDIT", "CREW", "CRIME", "CRIMINAL", "CRISIS", "CRITERIA", "CRITIC", "CRITICAL", "CRITICISM", "CRITICIZE", "CROP", "CROSS", 
                    "CROWD", "CRUCIAL", "CRY", "CULTURAL", "CULTURE", "CUP", "CURIOUS", "CURRENT", "CURRENTLY", "CURRICULUM", "CUSTOM", "CUSTOMER", "CUT", "CYCLE", "DAD", "DAILY", "DAMAGE", "DANCE", 
                    "DANGER", "DANGEROUS", "DARE", "DARK", "DARKNESS", "DATA", "DATE", "DAUGHTER", "DAY", "DEAD", "DEAL", "DEALER", "DEAR", "DEATH", "DEBATE", "DEBT", "DECADE", "DECIDE", "DECISION", 
                    "DECK", "DECLARE", "DECLINE", "DECREASE", "DEEP", "DEEPLY", "DEER", "DEFEAT", "DEFEND", "DEFENDANT", "DEFENSE", "DEFENSIVE", "DEFICIT", "DEFINE", "DEFINITELY", "DEFINITION", 
                    "DEGREE", "DELAY", "DELIVER", "DELIVERY", "DEMAND", "DEMOCRACY", "DEMOCRAT", "DEMOCRATIC", "DEMONSTRATE", "DEMONSTRATION", "DENY", "DEPARTMENT", "DEPEND", "DEPENDENT", "DEPENDING", 
                    "DEPICT", "DEPRESSION", "DEPTH", "DEPUTY", "DERIVE", "DESCRIBE", "DESCRIPTION", "DESERT", "DESERVE", "DESIGN", "DESIGNER", "DESIRE", "DESK", "DESPERATE", "DESPITE", "DESTROY", 
                    "DESTRUCTION", "DETAIL", "DETAILED", "DETECT", "DETERMINE", "DEVELOP", "DEVELOPING", "DEVELOPMENT", "DEVICE", "DEVOTE", "DIALOGUE", "DIE", "DIET", "DIFFER", "DIFFERENCE", 
                    "DIFFERENT", "DIFFERENTLY", "DIFFICULT", "DIFFICULTY", "DIG", "DIGITAL", "DIMENSION", "DINING", "DINNER", "DIRECT", "DIRECTION", "DIRECTLY", "DIRECTOR", "DIRT", "DIRTY", 
                    "DISABILITY", "DISAGREE", "DISAPPEAR", "DISASTER", "DISCIPLINE", "DISCOURSE", "DISCOVER", "DISCOVERY", "DISCRIMINATION", "DISCUSS", "DISCUSSION", "DISEASE", "DISH", "DISMISS", 
                    "DISORDER", "DISPLAY", "DISPUTE", "DISTANCE", "DISTANT", "DISTINCT", "DISTINCTION", "DISTINGUISH", "DISTRIBUTE", "DISTRIBUTION", "DISTRICT", "DIVERSE", "DIVERSITY", "DIVIDE", 
                    "DIVISION", "DIVORCE", "DNA", "DO", "DOCTOR", "DOCUMENT", "DOG", "DOMESTIC", "DOMINANT", "DOMINATE", "DOOR", "DOUBLE", "DOUBT", "DOWN", "DOWNTOWN", "DOZEN", "DRAFT", "DRAG", 
                    "DRAMA", "DRAMATIC", "DRAMATICALLY", "DRAW", "DRAWING", "DREAM", "DRESS", "DRINK", "DRIVE", "DRIVER", "DROP", "DRUG", "DRY", "DUE", "DURING", "DUST", "DUTY", "EACH", "EAGER", 
                    "EAR", "EARLY", "EARN", "EARNINGS", "EARTH", "EASE", "EASILY", "EAST", "EASTERN", "EASY", "EAT", "ECONOMIC", "ECONOMICS", "ECONOMIST", "ECONOMY", "EDGE", "EDITION", "EDITOR", 
                    "EDUCATE", "EDUCATION", "EDUCATIONAL", "EDUCATOR", "EFFECT", "EFFECTIVE", "EFFECTIVELY", "EFFICIENCY", "EFFICIENT", "EFFORT", "EGG", "EIGHT", "EITHER", "ELDERLY", "ELECT", 
                    "ELECTION", "ELECTRIC", "ELECTRICITY", "ELECTRONIC", "ELEMENT", "ELEMENTARY", "ELIMINATE", "ELITE", "ELSE", "ELSEWHERE", "E-MAIL", "EMBRACE", "EMERGE", "EMERGENCY", "EMISSION", 
                    "EMOTION", "EMOTIONAL", "EMPHASIS", "EMPHASIZE", "EMPLOY", "EMPLOYEE", "EMPLOYER", "EMPLOYMENT", "EMPTY", "ENABLE", "ENCOUNTER", "ENCOURAGE", "END", "ENEMY", "ENERGY", 
                    "ENFORCEMENT", "ENGAGE", "ENGINE", "ENGINEER", "ENGINEERING", "ENGLISH", "ENHANCE", "ENJOY", "ENORMOUS", "ENOUGH", "ENSURE", "ENTER", "ENTERPRISE", "ENTERTAINMENT", "ENTIRE", 
                    "ENTIRELY", "ENTRANCE", "ENTRY", "ENVIRONMENT", "ENVIRONMENTAL", "EPISODE", "EQUAL", "EQUALLY", "EQUIPMENT", "ERA", "ERROR", "ESCAPE", "ESPECIALLY", "ESSAY", "ESSENTIAL", 
                    "ESSENTIALLY", "ESTABLISH", "ESTABLISHMENT", "ESTATE", "ESTIMATE", "ETC", "ETHICS", "ETHNIC", "EUROPEAN", "EVALUATE", "EVALUATION", "EVEN", "EVENING", "EVENT", "EVENTUALLY", 
                    "EVER", "EVERY", "EVERYBODY", "EVERYDAY", "EVERYONE", "EVERYTHING", "EVERYWHERE", "EVIDENCE", "EVOLUTION", "EVOLVE", "EXACT", "EXACTLY", "EXAMINATION", "EXAMINE", "EXAMPLE", 
                    "EXCEED", "EXCELLENT", "EXCEPT", "EXCEPTION", "EXCHANGE", "EXCITING", "EXECUTIVE", "EXERCISE", "EXHIBIT", "EXHIBITION", "EXIST", "EXISTENCE", "EXISTING", "EXPAND", "EXPANSION", 
                    "EXPECT", "EXPECTATION", "EXPENSE", "EXPENSIVE", "EXPERIENCE", "EXPERIMENT", "EXPERT", "EXPLAIN", "EXPLANATION", "EXPLODE", "EXPLORE", "EXPLOSION", "EXPOSE", "EXPOSURE", "EXPRESS", 
                    "EXPRESSION", "EXTEND", "EXTENSION", "EXTENSIVE", "EXTENT", "EXTERNAL", "EXTRA", "EXTRAORDINARY", "EXTREME", "EXTREMELY", "EYE", "FABRIC", "FACE", "FACILITY", "FACT", "FACTOR", 
                    "FACTORY", "FACULTY", "FADE", "FAIL", "FAILURE", "FAIR", "FAIRLY", "FAITH", "FALL", "FALSE", "FAMILIAR", "FAMILY", "FAMOUS", "FAN", "FANTASY", "FAR", "FARM", "FARMER", "FASHION", 
                    "FAST", "FAT", "FATE", "FATHER", "FAULT", "FAVOR", "FAVORITE", "FEAR", "FEATURE", "FEDERAL", "FEE", "FEED", "FEEL", "FEELING", "FELLOW", "FEMALE", "FENCE", "FEW", "FEWER", "FIBER", 
                    "FICTION", "FIELD", "FIFTEEN", "FIFTH", "FIFTY", "FIGHT", "FIGHTER", "FIGHTING", "FIGURE", "FILE", "FILL", "FILM", "FINAL", "FINALLY", "FINANCE", "FINANCIAL", "FIND", "FINDING", 
                    "FINE", "FINGER", "FINISH", "FIRE", "FIRM", "FIRST", "FISH", "FISHING", "FIT", "FITNESS", "FIVE", "FIX", "FLAG", "FLAME", "FLAT", "FLAVOR", "FLEE", "FLESH", "FLIGHT", "FLOAT", 
                    "FLOOR", "FLOW", "FLOWER", "FLY", "FOCUS", "FOLK", "FOLLOW", "FOLLOWING", "FOOD", "FOOT", "FOOTBALL", "FOR", "FORCE", "FOREIGN", "FOREST", "FOREVER", "FORGET", "FORM", "FORMAL", 
                    "FORMATION", "FORMER", "FORMULA", "FORTH", "FORTUNE", "FORWARD", "FOUND", "FOUNDATION", "FOUNDER", "FOUR", "FOURTH", "FRAME", "FRAMEWORK", "FREE", "FREEDOM", "FREEZE", "FRENCH", 
                    "FREQUENCY", "FREQUENT", "FREQUENTLY", "FRESH", "FRIEND", "FRIENDLY", "FRIENDSHIP", "FROM", "FRONT", "FRUIT", "FRUSTRATION", "FUEL", "FULL", "FULLY", "FUN", "FUNCTION", "FUND", 
                    "FUNDAMENTAL", "FUNDING", "FUNERAL", "FUNNY", "FURNITURE", "FURTHERMORE", "FUTURE", "GAIN", "GALAXY", "GALLERY", "GAME", "GANG", "GAP", "GARAGE", "GARDEN", "GARLIC", "GAS", "GATE", 
                    "GATHER", "GAY", "GAZE", "GEAR", "GENDER", "GENE", "GENERAL", "GENERALLY", "GENERATE", "GENERATION", "GENETIC", "GENTLEMAN", "GENTLY", "GERMAN", "GESTURE", "GET", "GHOST", "GIANT", 
                    "GIFT", "GIFTED", "GIRL", "GIRLFRIEND", "GIVE", "GIVEN", "GLAD", "GLANCE", "GLASS", "GLOBAL", "GLOVE", "GO", "GOAL", "GOD", "GOLD", "GOLDEN", "GOLF", "GOOD", "GOVERNMENT", 
                    "GOVERNOR", "GRAB", "GRADE", "GRADUALLY", "GRADUATE", "GRAIN", "GRAND", "GRANDFATHER", "GRANDMOTHER", "GRANT", "GRASS", "GRAVE", "GRAY", "GREAT", "GREATEST", "GREEN", "GROCERY", 
                    "GROUND", "GROUP", "GROW", "GROWING", "GROWTH", "GUARANTEE", "GUARD", "GUESS", "GUEST", "GUIDE", "GUIDELINE", "GUILTY", "GUN", "GUY", "HABIT", "HABITAT", "HAIR", "HALF", "HALL", 
                    "HAND", "HANDFUL", "HANDLE", "HANG", "HAPPEN", "HAPPY", "HARD", "HARDLY", "HAT", "HATE", "HAVE", "HE", "HEAD", "HEADLINE", "HEADQUARTERS", "HEALTH", "HEALTHY", "HEAR", "HEARING", 
                    "HEART", "HEAT", "HEAVEN", "HEAVILY", "HEAVY", "HEEL", "HEIGHT", "HELICOPTER", "HELL", "HELLO", "HELP", "HELPFUL", "HER", "HERE", "HERITAGE", "HERO", "HERSELF", "HEY", "HI", 
                    "HIDE", "HIGH", "HIGHLIGHT", "HIGHLY", "HIGHWAY", "HILL", "HIM", "HIMSELF", "HIP", "HIRE", "HIS", "HISTORIAN", "HISTORIC", "HISTORICAL", "HISTORY", "HIT", "HOLD", "HOLE", 
                    "HOLIDAY", "HOLY", "HOME", "HOMELESS", "HONEST", "HONEY", "HONOR", "HOPE", "HORIZON", "HORROR", "HORSE", "HOSPITAL", "HOST", "HOT", "HOTEL", "HOUR", "HOUSE", "HOUSEHOLD", 
                    "HOUSING", "HOW", "HOWEVER", "HUGE", "HUMAN", "HUMOR", "HUNDRED", "HUNGRY", "HUNTER", "HUNTING", "HURT", "HUSBAND", "HYPOTHESIS", "I", "ICE", "IDEA", "IDEAL", "IDENTIFICATION", 
                    "IDENTIFY", "IDENTITY", "IE", "IF", "IGNORE", "ILL", "ILLEGAL", "ILLNESS", "ILLUSTRATE", "IMAGE", "IMAGINATION", "IMAGINE", "IMMEDIATE", "IMMEDIATELY", "IMMIGRANT", "IMMIGRATION", 
                    "IMPACT", "IMPLEMENT", "IMPLICATION", "IMPLY", "IMPORTANCE", "IMPORTANT", "IMPOSE", "IMPOSSIBLE", "IMPRESS", "IMPRESSION", "IMPRESSIVE", "IMPROVE", "IMPROVEMENT", "IN", 
                    "INCENTIVE", "INCIDENT", "INCLUDE", "INCLUDING", "INCOME", "INCORPORATE", "INCREASE", "INCREASED", "INCREASING", "INCREASINGLY", "INCREDIBLE", "INDEED", "INDEPENDENCE", 
                    "INDEPENDENT", "INDEX", "INDIAN", "INDICATE", "INDICATION", "INDIVIDUAL", "INDUSTRIAL", "INDUSTRY", "INFANT", "INFECTION", "INFLATION", "INFLUENCE", "INFORM", "INFORMATION", 
                    "INGREDIENT", "INITIAL", "INITIALLY", "INITIATIVE", "INJURY", "INNER", "INNOCENT", "INQUIRY", "INSIDE", "INSIGHT", "INSIST", "INSPIRE", "INSTALL", "INSTANCE", "INSTEAD", 
                    "INSTITUTION", "INSTITUTIONAL", "INSTRUCTION", "INSTRUCTOR", "INSTRUMENT", "INSURANCE", "INTELLECTUAL", "INTELLIGENCE", "INTEND", "INTENSE", "INTENSITY", "INTENTION", 
                    "INTERACTION", "INTEREST", "INTERESTED", "INTERESTING", "INTERNAL", "INTERNATIONAL", "INTERNET", "INTERPRET", "INTERPRETATION", "INTERVENTION", "INTERVIEW", "INTO", "INTRODUCE", 
                    "INTRODUCTION", "INVASION", "INVEST", "INVESTIGATE", "INVESTIGATION", "INVESTIGATOR", "INVESTMENT", "INVESTOR", "INVITE", "INVOLVE", "INVOLVED", "INVOLVEMENT", "IRAQI", "IRISH", 
                    "IRON", "ISLAMIC", "ISLAND", "ISRAELI", "ISSUE", "IT", "ITALIAN", "ITEM", "ITS", "ITSELF", "JACKET", "JAIL", "JAPANESE", "JET", "JEW", "JEWISH", "JOB", "JOIN", "JOINT", "JOKE", 
                    "JOURNAL", "JOURNALIST", "JOURNEY", "JOY", "JUDGE", "JUDGMENT", "JUICE", "JUMP", "JUNIOR", "JURY", "JUST", "JUSTICE", "JUSTIFY", "KEEP", "KEY", "KICK", "KID", "KILL", "KILLER", 
                    "KILLING", "KIND", "KING", "KISS", "KITCHEN", "KNEE", "KNIFE", "KNOCK", "KNOW", "KNOWLEDGE", "LAB", "LABEL", "LABOR", "LABORATORY", "LACK", "LADY", "LAKE", "LAND", "LANDSCAPE", 
                    "LANGUAGE", "LAP", "LARGE", "LARGELY", "LAST", "LATE", "LATER", "LATIN", "LATTER", "LAUGH", "LAUNCH", "LAW", "LAWN", "LAWSUIT", "LAWYER", "LAY", "LAYER", "LEAD", "LEADER", 
                    "LEADERSHIP", "LEADING", "LEAF", "LEAGUE", "LEAN", "LEARN", "LEARNING", "LEAST", "LEATHER", "LEAVE", "LEFT", "LEG", "LEGACY", "LEGAL", "LEGEND", "LEGISLATION", "LEGITIMATE", 
                    "LEMON", "LENGTH", "LESS", "LESSON", "LET", "LETTER", "LEVEL", "LIBERAL", "LIBRARY", "LICENSE", "LIE", "LIFE", "LIFESTYLE", "LIFETIME", "LIFT", "LIGHT", "LIKE", "LIKELY", "LIMIT", 
                    "LIMITATION", "LIMITED", "LINE", "LINK", "LIP", "LIST", "LISTEN", "LITERALLY", "LITERARY", "LITERATURE", "LITTLE", "LIVE", "LIVING", "LOAD", "LOAN", "LOCAL", "LOCATE", "LOCATION", 
                    "LOCK", "LONG", "LONG-TERM", "LOOK", "LOOSE", "LOSE", "LOSS", "LOST", "LOT", "LOTS", "LOUD", "LOVE", "LOVELY", "LOVER", "LOW", "LOWER", "LUCK", "LUCKY", "LUNCH", "LUNG", "MACHINE", 
                    "MAD", "MAGAZINE", "MAIL", "MAIN", "MAINLY", "MAINTAIN", "MAINTENANCE", "MAJOR", "MAJORITY", "MAKE", "MAKER", "MAKEUP", "MALE", "MALL", "MAN", "MANAGE", "MANAGEMENT", "MANAGER", 
                    "MANNER", "MANUFACTURER", "MANUFACTURING", "MANY", "MAP", "MARGIN", "MARK", "MARKET", "MARKETING", "MARRIAGE", "MARRIED", "MARRY", "MASK", "MASS", "MASSIVE", "MASTER", "MATCH", 
                    "MATERIAL", "MATH", "MATTER", "MAY", "MAYBE", "MAYOR", "ME", "MEAL", "MEAN", "MEANING", "MEANWHILE", "MEASURE", "MEASUREMENT", "MEAT", "MECHANISM", "MEDIA", "MEDICAL", 
                    "MEDICATION", "MEDICINE", "MEDIUM", "MEET", "MEETING", "MEMBER", "MEMBERSHIP", "MEMORY", "MENTAL", "MENTION", "MENU", "MERE", "MERELY", "MESS", "MESSAGE", "METAL", "METER", 
                    "METHOD", "MEXICAN", "MIDDLE", "MIGHT", "MILITARY", "MILK", "MILLION", "MIND", "MINE", "MINISTER", "MINOR", "MINORITY", "MINUTE", "MIRACLE", "MIRROR", "MISS", "MISSILE", "MISSION", 
                    "MISTAKE", "MIX", "MIXTURE", "MM-HMM", "MODE", "MODEL", "MODERATE", "MODERN", "MODEST", "MOM", "MOMENT", "MONEY", "MONITOR", "MONTH", "MOOD", "MOON", "MORAL", "MORE", "MOREOVER", 
                    "MORNING", "MORTGAGE", "MOST", "MOSTLY", "MOTHER", "MOTION", "MOTIVATION", "MOTOR", "MOUNT", "MOUNTAIN", "MOUSE", "MOUTH", "MOVE", "MOVEMENT", "MOVIE", "MR", "MRS", "MS", "MUCH", 
                    "MULTIPLE", "MURDER", "MUSCLE", "MUSEUM", "MUSIC", "MUSICAL", "MUSICIAN", "MUSLIM", "MUST", "MUTUAL", "MY", "MYSELF", "MYSTERY", "MYTH", "NAKED", "NAME", "NARRATIVE", "NARROW", 
                    "NATION", "NATIONAL", "NATIVE", "NATURAL", "NATURALLY", "NATURE", "NEAR", "NEARBY", "NEARLY", "NECESSARILY", "NECESSARY", "NECK", "NEED", "NEGATIVE", "NEGOTIATE", "NEGOTIATION", 
                    "NEIGHBOR", "NEIGHBORHOOD", "NEITHER", "NERVE", "NERVOUS", "NET", "NETWORK", "NEVER", "NEVERTHELESS", "NEW", "NEWLY", "NEWS", "NEWSPAPER", "NEXT", "NICE", "NIGHT", "NINE", "NO", 
                    "NOBODY", "NOD", "NOISE", "NOMINATION", "NONE", "NONETHELESS", "NOR", "NORMAL", "NORMALLY", "NORTH", "NORTHERN", "NOSE", "NOT", "NOTE", "NOTHING", "NOTICE", "NOTION", "NOVEL", 
                    "NOW", "NOWHERE", "N'T", "NUCLEAR", "NUMBER", "NUMEROUS", "NURSE", "NUT", "OBJECT", "OBJECTIVE", "OBLIGATION", "OBSERVATION", "OBSERVE", "OBSERVER", "OBTAIN", "OBVIOUS", 
                    "OBVIOUSLY", "OCCASION", "OCCASIONALLY", "OCCUPATION", "OCCUPY", "OCCUR", "OCEAN", "ODD", "ODDS", "OF", "OFF", "OFFENSE", "OFFENSIVE", "OFFER", "OFFICE", "OFFICER", "OFFICIAL", 
                    "OFTEN", "OH", "OIL", "OK", "OKAY", "OLD", "OLYMPIC", "ON", "ONCE", "ONE", "ONGOING", "ONION", "ONLINE", "ONLY", "ONTO", "OPEN", "OPENING", "OPERATE", "OPERATING", "OPERATION", 
                    "OPERATOR", "OPINION", "OPPONENT", "OPPORTUNITY", "OPPOSE", "OPPOSITE", "OPPOSITION", "OPTION", "OR", "ORANGE", "ORDER", "ORDINARY", "ORGANIC", "ORGANIZATION", "ORGANIZE", 
                    "ORIENTATION", "ORIGIN", "ORIGINAL", "ORIGINALLY", "OTHER", "OTHERS", "OTHERWISE", "OUGHT", "OUR", "OURSELVES", "OUT", "OUTCOME", "OUTSIDE", "OVEN", "OVER", "OVERALL", "OVERCOME", 
                    "OVERLOOK", "OWE", "OWN", "OWNER", "PACE", "PACK", "PACKAGE", "PAGE", "PAIN", "PAINFUL", "PAINT", "PAINTER", "PAINTING", "PAIR", "PALE", "PALESTINIAN", "PALM", "PAN", "PANEL", 
                    "PANT", "PAPER", "PARENT", "PARK", "PARKING", "PART", "PARTICIPANT", "PARTICIPATE", "PARTICIPATION", "PARTICULAR", "PARTICULARLY", "PARTLY", "PARTNER", "PARTNERSHIP", "PARTY", 
                    "PASS", "PASSAGE", "PASSENGER", "PASSION", "PAST", "PATCH", "PATH", "PATIENT", "PATTERN", "PAUSE", "PAY", "PAYMENT", "PC", "PEACE", "PEAK", "PEER", "PENALTY", "PEOPLE", "PEPPER", 
                    "PER", "PERCEIVE", "PERCENTAGE", "PERCEPTION", "PERFECT", "PERFECTLY", "PERFORM", "PERFORMANCE", "PERHAPS", "PERIOD", "PERMANENT", "PERMISSION", "PERMIT", "PERSON", "PERSONAL", 
                    "PERSONALITY", "PERSONALLY", "PERSONNEL", "PERSPECTIVE", "PERSUADE", "PET", "PHASE", "PHENOMENON", "PHILOSOPHY", "PHONE", "PHOTO", "PHOTOGRAPH", "PHOTOGRAPHER", "PHRASE", 
                    "PHYSICAL", "PHYSICALLY", "PHYSICIAN", "PIANO", "PICK", "PICTURE", "PIE", "PIECE", "PILE", "PILOT", "PINE", "PINK", "PIPE", "PITCH", "PLACE", "PLAN", "PLANE", "PLANET", "PLANNING", 
                    "PLANT", "PLASTIC", "PLATE", "PLATFORM", "PLAY", "PLAYER", "PLEASE", "PLEASURE", "PLENTY", "PLOT", "PLUS", "PM", "POCKET", "POEM", "POET", "POETRY", "POINT", "POLE", "POLICE", 
                    "POLICY", "POLITICAL", "POLITICALLY", "POLITICIAN", "POLITICS", "POLL", "POLLUTION", "POOL", "POOR", "POP", "POPULAR", "POPULATION", "PORCH", "PORT", "PORTION", "PORTRAIT", 
                    "PORTRAY", "POSE", "POSITION", "POSITIVE", "POSSESS", "POSSIBILITY", "POSSIBLE", "POSSIBLY", "POST", "POT", "POTATO", "POTENTIAL", "POTENTIALLY", "POUND", "POUR", "POVERTY", 
                    "POWDER", "POWER", "POWERFUL", "PRACTICAL", "PRACTICE", "PRAY", "PRAYER", "PRECISELY", "PREDICT", "PREFER", "PREFERENCE", "PREGNANCY", "PREGNANT", "PREPARATION", "PREPARE", 
                    "PRESCRIPTION", "PRESENCE", "PRESENT", "PRESENTATION", "PRESERVE", "PRESIDENT", "PRESIDENTIAL", "PRESS", "PRESSURE", "PRETEND", "PRETTY", "PREVENT", "PREVIOUS", "PREVIOUSLY", 
                    "PRICE", "PRIDE", "PRIEST", "PRIMARILY", "PRIMARY", "PRIME", "PRINCIPAL", "PRINCIPLE", "PRINT", "PRIOR", "PRIORITY", "PRISON", "PRISONER", "PRIVACY", "PRIVATE", "PROBABLY", 
                    "PROBLEM", "PROCEDURE", "PROCEED", "PROCESS", "PRODUCE", "PRODUCER", "PRODUCT", "PRODUCTION", "PROFESSION", "PROFESSIONAL", "PROFESSOR", "PROFILE", "PROFIT", "PROGRAM", "PROGRESS", 
                    "PROJECT", "PROMINENT", "PROMISE", "PROMOTE", "PROMPT", "PROOF", "PROPER", "PROPERLY", "PROPERTY", "PROPORTION", "PROPOSAL", "PROPOSE", "PROPOSED", "PROSECUTOR", "PROSPECT", 
                    "PROTECT", "PROTECTION", "PROTEIN", "PROTEST", "PROUD", "PROVE", "PROVIDE", "PROVIDER", "PROVINCE", "PROVISION", "PSYCHOLOGICAL", "PSYCHOLOGIST", "PSYCHOLOGY", "PUBLIC", 
                    "PUBLICATION", "PUBLICLY", "PUBLISH", "PUBLISHER", "PULL", "PUNISHMENT", "PURCHASE", "PURE", "PURPOSE", "PURSUE", "PUSH", "PUT", "QUALIFY", "QUALITY", "QUARTER", "QUARTERBACK", 
                    "QUESTION", "QUICK", "QUICKLY", "QUIET", "QUIETLY", "QUIT", "QUITE", "QUOTE", "RACE", "RACIAL", "RADICAL", "RADIO", "RAIL", "RAIN", "RAISE", "RANGE", "RANK", "RAPID", "RAPIDLY", 
                    "RARE", "RARELY", "RATE", "RATHER", "RATING", "RATIO", "RAW", "REACH", "REACT", "REACTION", "READ", "READER", "READING", "READY", "REAL", "REALITY", "REALIZE", "REALLY", "REASON", 
                    "REASONABLE", "RECALL", "RECEIVE", "RECENT", "RECENTLY", "RECIPE", "RECOGNITION", "RECOGNIZE", "RECOMMEND", "RECOMMENDATION", "RECORD", "RECORDING", "RECOVER", "RECOVERY", 
                    "RECRUIT", "RED", "REDUCE", "REDUCTION", "REFER", "REFERENCE", "REFLECT", "REFLECTION", "REFORM", "REFUGEE", "REFUSE", "REGARD", "REGARDING", "REGARDLESS", "REGIME", "REGION", 
                    "REGIONAL", "REGISTER", "REGULAR", "REGULARLY", "REGULATE", "REGULATION", "REINFORCE", "REJECT", "RELATE", "RELATION", "RELATIONSHIP", "RELATIVE", "RELATIVELY", "RELAX", "RELEASE", 
                    "RELEVANT", "RELIEF", "RELIGION", "RELIGIOUS", "RELY", "REMAIN", "REMAINING", "REMARKABLE", "REMEMBER", "REMIND", "REMOTE", "REMOVE", "REPEAT", "REPEATEDLY", "REPLACE", "REPLY", 
                    "REPORT", "REPORTER", "REPRESENT", "REPRESENTATION", "REPRESENTATIVE", "REPUBLICAN", "REPUTATION", "REQUEST", "REQUIRE", "REQUIREMENT", "RESEARCH", "RESEARCHER", "RESEMBLE", 
                    "RESERVATION", "RESIDENT", "RESIST", "RESISTANCE", "RESOLUTION", "RESOLVE", "RESORT", "RESOURCE", "RESPECT", "RESPOND", "RESPONDENT", "RESPONSE", "RESPONSIBILITY", "RESPONSIBLE", 
                    "REST", "RESTAURANT", "RESTORE", "RESTRICTION", "RESULT", "RETAIN", "RETIRE", "RETIREMENT", "RETURN", "REVEAL", "REVENUE", "REVIEW", "REVOLUTION", "RHYTHM", "RICE", "RICH", "RID", 
                    "RIDE", "RIFLE", "RIGHT", "RING", "RISE", "RISK", "RIVER", "ROAD", "ROCK", "ROLE", "ROLL", "ROMANTIC", "ROOF", "ROOM", "ROOT", "ROPE", "ROSE", "ROUGH", "ROUGHLY", "ROUND", "ROUTE", 
                    "ROUTINE", "ROW", "RUB", "RULE", "RUN", "RUNNING", "RURAL", "RUSH", "RUSSIAN", "SACRED", "SAD", "SAFE", "SAFETY", "SAKE", "SALAD", "SALARY", "SALE", "SALES", "SALT", "SAME", 
                    "SAMPLE", "SANCTION", "SAND", "SATELLITE", "SATISFACTION", "SATISFY", "SAUCE", "SAVE", "SAVING", "SAY", "SCALE", "SCANDAL", "SCARED", "SCENARIO", "SCENE", "SCHEDULE", "SCHEME", 
                    "SCHOLAR", "SCHOLARSHIP", "SCHOOL", "SCIENCE", "SCIENTIFIC", "SCIENTIST", "SCOPE", "SCORE", "SCREAM", "SCREEN", "SCRIPT", "SEA", "SEARCH", "SEASON", "SEAT", "SECOND", "SECRET", 
                    "SECRETARY", "SECTION", "SECTOR", "SECURE", "SECURITY", "SEE", "SEED", "SEEK", "SEEM", "SEGMENT", "SEIZE", "SELECT", "SELECTION", "SELF", "SELL", "SENATE", "SENATOR", "SEND", 
                    "SENIOR", "SENSE", "SENSITIVE", "SENTENCE", "SEPARATE", "SEQUENCE", "SERIES", "SERIOUS", "SERIOUSLY", "SERVE", "SERVICE", "SESSION", "SET", "SETTING", "SETTLE", "SETTLEMENT", 
                    "SEVEN", "SEVERAL", "SEVERE", "SEX", "SEXUAL", "SHADE", "SHADOW", "SHAKE", "SHALL", "SHAPE", "SHARE", "SHARP", "SHE", "SHEET", "SHELF", "SHELL", "SHELTER", "SHIFT", "SHINE", 
                    "SHIP", "SHIRT", "SHIT", "SHOCK", "SHOE", "SHOOT", "SHOOTING", "SHOP", "SHOPPING", "SHORE", "SHORT", "SHORTLY", "SHOT", "SHOULD", "SHOULDER", "SHOUT", "SHOW", "SHOWER", "SHRUG", 
                    "SHUT", "SICK", "SIDE", "SIGH", "SIGHT", "SIGN", "SIGNAL", "SIGNIFICANCE", "SIGNIFICANT", "SIGNIFICANTLY", "SILENCE", "SILENT", "SILVER", "SIMILAR", "SIMILARLY", "SIMPLE", 
                    "SIMPLY", "SIN", "SINCE", "SING", "SINGER", "SINGLE", "SINK", "SIR", "SISTER", "SIT", "SITE", "SITUATION", "SIX", "SIZE", "SKI", "SKILL", "SKIN", "SKY", "SLAVE", "SLEEP", "SLICE", 
                    "SLIDE", "SLIGHT", "SLIGHTLY", "SLIP", "SLOW", "SLOWLY", "SMALL", "SMART", "SMELL", "SMILE", "SMOKE", "SMOOTH", "SNAP", "SNOW", "SO", "SO-CALLED", "SOCCER", "SOCIAL", "SOCIETY", 
                    "SOFT", "SOFTWARE", "SOIL", "SOLAR", "SOLDIER", "SOLID", "SOLUTION", "SOLVE", "SOME", "SOMEBODY", "SOMEHOW", "SOMEONE", "SOMETHING", "SOMETIMES", "SOMEWHAT", "SOMEWHERE", "SON", 
                    "SONG", "SOON", "SOPHISTICATED", "SORRY", "SORT", "SOUL", "SOUND", "SOUP", "SOURCE", "SOUTH", "SOUTHERN", "SOVIET", "SPACE", "SPANISH", "SPEAK", "SPEAKER", "SPECIAL", "SPECIALIST", 
                    "SPECIES", "SPECIFIC", "SPECIFICALLY", "SPEECH", "SPEED", "SPEND", "SPENDING", "SPIN", "SPIRIT", "SPIRITUAL", "SPLIT", "SPOKESMAN", "SPORT", "SPOT", "SPREAD", "SPRING", "SQUARE", 
                    "SQUEEZE", "STABILITY", "STABLE", "STAFF", "STAGE", "STAIR", "STAKE", "STAND", "STANDARD", "STANDING", "STAR", "STARE", "START", "STATE", "STATEMENT", "STATION", "STATISTICS", 
                    "STATUS", "STAY", "STEADY", "STEAL", "STEEL", "STEP", "STICK", "STILL", "STIR", "STOCK", "STOMACH", "STONE", "STOP", "STORAGE", "STORE", "STORM", "STORY", "STRAIGHT", "STRANGE", 
                    "STRANGER", "STRATEGIC", "STRATEGY", "STREAM", "STREET", "STRENGTH", "STRENGTHEN", "STRESS", "STRETCH", "STRIKE", "STRING", "STRIP", "STROKE", "STRONG", "STRONGLY", "STRUCTURE", 
                    "STRUGGLE", "STUDENT", "STUDIO", "STUDY", "STUFF", "STUPID", "STYLE", "SUBJECT", "SUBMIT", "SUBSEQUENT", "SUBSTANCE", "SUBSTANTIAL", "SUCCEED", "SUCCESS", "SUCCESSFUL", 
                    "SUCCESSFULLY", "SUCH", "SUDDEN", "SUDDENLY", "SUE", "SUFFER", "SUFFICIENT", "SUGAR", "SUGGEST", "SUGGESTION", "SUICIDE", "SUIT", "SUMMER", "SUMMIT", "SUN", "SUPER", "SUPPLY", 
                    "SUPPORT", "SUPPORTER", "SUPPOSE", "SUPPOSED", "SUPREME", "SURE", "SURELY", "SURFACE", "SURGERY", "SURPRISE", "SURPRISED", "SURPRISING", "SURPRISINGLY", "SURROUND", "SURVEY", 
                    "SURVIVAL", "SURVIVE", "SURVIVOR", "SUSPECT", "SUSTAIN", "SWEAR", "SWEEP", "SWEET", "SWIM", "SWING", "SWITCH", "SYMBOL", "SYMPTOM", "SYSTEM", "TABLE", "TABLESPOON", "TACTIC", 
                    "TAIL", "TAKE", "TALE", "TALENT", "TALK", "TALL", "TANK", "TAP", "TAPE", "TARGET", "TASK", "TASTE", "TAX", "TAXPAYER", "TEA", "TEACH", "TEACHER", "TEACHING", "TEAM", "TEAR", 
                    "TEASPOON", "TECHNICAL", "TECHNIQUE", "TECHNOLOGY", "TEEN", "TEENAGER", "TELEPHONE", "TELESCOPE", "TELEVISION", "TELL", "TEMPERATURE", "TEMPORARY", "TEN", "TEND", "TENDENCY", 
                    "TENNIS", "TENSION", "TENT", "TERM", "TERMS", "TERRIBLE", "TERRITORY", "TERROR", "TERRORISM", "TERRORIST", "TEST", "TESTIFY", "TESTIMONY", "TESTING", "TEXT", "THAN", "THANK", 
                    "THANKS", "THAT", "THE", "THEATER", "THEIR", "THEM", "THEME", "THEMSELVES", "THEN", "THEORY", "THERAPY", "THERE", "THEREFORE", "THESE", "THEY", "THICK", "THIN", "THING", "THINK", 
                    "THINKING", "THIRD", "THIRTY", "THIS", "THOSE", "THOUGH", "THOUGHT", "THOUSAND", "THREAT", "THREATEN", "THREE", "THROAT", "THROUGH", "THROUGHOUT", "THROW", "THUS", "TICKET", "TIE", 
                    "TIGHT", "TIME", "TINY", "TIP", "TIRE", "TIRED", "TISSUE", "TITLE", "TO", "TOBACCO", "TODAY", "TOE", "TOGETHER", "TOMATO", "TOMORROW", "TONE", "TONGUE", "TONIGHT", "TOO", "TOOL", 
                    "TOOTH", "TOP", "TOPIC", "TOSS", "TOTAL", "TOTALLY", "TOUCH", "TOUGH", "TOUR", "TOURIST", "TOURNAMENT", "TOWARD", "TOWARDS", "TOWER", "TOWN", "TOY", "TRACE", "TRACK", "TRADE", 
                    "TRADITION", "TRADITIONAL", "TRAFFIC", "TRAGEDY", "TRAIL", "TRAIN", "TRAINING", "TRANSFER", "TRANSFORM", "TRANSFORMATION", "TRANSITION", "TRANSLATE", "TRANSPORTATION", "TRAVEL", 
                    "TREAT", "TREATMENT", "TREATY", "TREE", "TREMENDOUS", "TREND", "TRIAL", "TRIBE", "TRICK", "TRIP", "TROOP", "TROUBLE", "TRUCK", "TRUE", "TRULY", "TRUST", "TRUTH", "TRY", "TUBE", 
                    "TUNNEL", "TURN", "TV", "TWELVE", "TWENTY", "TWICE", "TWIN", "TWO", "TYPE", "TYPICAL", "TYPICALLY", "UGLY", "ULTIMATE", "ULTIMATELY", "UNABLE", "UNCLE", "UNDER", "UNDERGO", 
                    "UNDERSTAND", "UNDERSTANDING", "UNFORTUNATELY", "UNIFORM", "UNION", "UNIQUE", "UNIT", "UNITED", "UNIVERSAL", "UNIVERSE", "UNIVERSITY", "UNKNOWN", "UNLESS", "UNLIKE", "UNLIKELY", 
                    "UNTIL", "UNUSUAL", "UP", "UPON", "UPPER", "URBAN", "URGE", "US", "USE", "USED", "USEFUL", "USER", "USUAL", "USUALLY", "UTILITY", "VACATION", "VALLEY", "VALUABLE", "VALUE", 
                    "VARIABLE", "VARIATION", "VARIETY", "VARIOUS", "VARY", "VAST", "VEGETABLE", "VEHICLE", "VENTURE", "VERSION", "VERSUS", "VERY", "VESSEL", "VETERAN", "VIA", "VICTIM", "VICTORY", 
                    "VIDEO", "VIEW", "VIEWER", "VILLAGE", "VIOLATE", "VIOLATION", "VIOLENCE", "VIOLENT", "VIRTUALLY", "VIRTUE", "VIRUS", "VISIBLE", "VISION", "VISIT", "VISITOR", "VISUAL", "VITAL", 
                    "VOICE", "VOLUME", "VOLUNTEER", "VOTE", "VOTER", "VS", "VULNERABLE", "WAGE", "WAIT", "WAKE", "WALK", "WALL", "WANDER", "WANT", "WAR", "WARM", "WARN", "WARNING", "WASH", "WASTE", 
                    "WATCH", "WATER", "WAVE", "WAY", "WE", "WEAK", "WEALTH", "WEALTHY", "WEAPON", "WEAR", "WEATHER", "WEDDING", "WEEK", "WEEKEND", "WEEKLY", "WEIGH", "WEIGHT", "WELCOME", "WELFARE", 
                    "WELL", "WEST", "WESTERN", "WET", "WHAT", "WHATEVER", "WHEEL", "WHEN", "WHENEVER", "WHERE", "WHEREAS", "WHETHER", "WHICH", "WHILE", "WHISPER", "WHITE", "WHO", "WHOLE", "WHOM", 
                    "WHOSE", "WHY", "WIDE", "WIDELY", "WIDESPREAD", "WIFE", "WILD", "WILL", "WILLING", "WIN", "WIND", "WINDOW", "WINE", "WING", "WINNER", "WINTER", "WIPE", "WIRE", "WISDOM", "WISE", 
                    "WISH", "WITH", "WITHDRAW", "WITHIN", "WITHOUT", "WITNESS", "WOMAN", "WONDER", "WONDERFUL", "WOOD", "WOODEN", "WORD", "WORK", "WORKER", "WORKING", "WORKS", "WORKSHOP", "WORLD", 
                    "WORRIED", "WORRY", "WORTH", "WOULD", "WOUND", "WRAP", "WRITE", "WRITER", "WRITING", "WRONG", "YARD", "YEAH", "YEAR", "YELL", "YELLOW", "YES", "YESTERDAY", "YET", "YIELD", "YOU", 
                    "YOUNG", "YOUR", "YOURS", "YOURSELF", "YOUTH", "ZONE"]
          
